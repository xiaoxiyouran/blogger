
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

	<title>链接</title>
	<meta name="keywords" content="xiaoxiyouran" />
	<meta name="description" content="xiaoxiyouran's Docs" />
	<link href="../../../../packages/css/bootstrap.min.css" rel="stylesheet" />
	<link href="../../../../packages/css/style.css" rel="stylesheet" />
	<link href="../../../../packages/css/monokai_sublime.min.css" rel="stylesheet">
	
	<!-- 右上角的侧边导航栏 -->
	<link rel="stylesheet" href="../../../../packages/hock_side_bar/css/sidebar.css"> <!--初始化文件-->
	<script src="../../../../packages/hock_side_bar/js/sidebar.js"></script> <!--rem适配js-->
	
	<!--
	<link href="<?php echo $base_url?>/css/bootstrap-theme.min.css" rel="stylesheet" />
	-->
	
	<!-- To generate the side tree of the document itself. -->
  <link rel="stylesheet" href="../../../../packages/generate_header_sidebar/css/zTreeStyle/zTreeStyle.css" type="text/css">
  <style>
  body {
  background-color: white;
  margin:0; padding:0;
  // text-align: center;
  overflow: scroll;
  }
  div, p, table, th, td {
    list-style:none;
    margin:8px; padding:0;
    color:#333; font-size:12px;
   Font-family: Helvetica, Tahoma, Arial, STXihei, “华文细黑”, “Microsoft YaHei”, “微软雅黑”, SimSun, “宋体”, Heiti, “黑体”, sans-serif;
  }
  
 // table{
 //   border-collapse:collapse;
 // }

  //table, td, th{
  //  border:1px solid black;   
  //}
  
  .ztree li a.curSelectedNode {
    padding-top: 0px;
    background-color: #FFE6B0;
    color: black;
    height: 16px;
    border: 1px #FFB951 solid;
    opacity: 0.8;
  }
  .ztree{
    overflow: auto;
    height:100%;
    min-height: 200px;
    top: 0px;
  }
  </style>

<!--
  For Latex formula
-->
<!--
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"],["\(","\)"]]}
  });
</script>
-->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"]]}
  });
</script>
 <script type="text/javascript" src="../../../../packages/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>

<!-- mermaid 画图 -->
 <link rel="stylesheet" href="../../../../packages/mermaid-7.0.0/dist/mermaid.forest.css"/>
 <script src="../../../../packages/mermaid-7.0.0/dist/mermaid.js"></script>
 <script src="../../../../packages/mermaid-7.0.0/dist/dist/mermaid.full.js"></script>
 <!-- <scrpt src="../../../../packages/mermaid-7.0.0/node_modules/d3/d3.js"></scrpt> -->
 <!-- <script>mermaid.initialize({startOnLoad:true});</script>  -->
 <script>
	//browserify --entry src/mermaid.js -u d3 -o ./dist/mermaid.brow.slim.js
			var mermaid_config = {
					startOnLoad:true
			}
			mermaid.ganttConfig = {
					titleTopMargin:25,
					barHeight:20,
					barGap:4,
					topPadding:50,
					leftPadding:75,
					gridLineStartPadding:35,
					fontSize:11,
					numberSectionStyles:3,
					axisFormatter: [
							// Within a day
							["%I:%M", function (d) {
									return d.getHours();
							}],
							// Monday a week
							["w. %U", function (d) {
									return d.getDay() == 1;
							}],
							// Day within a week (not monday)
							["%a %d", function (d) {
									return d.getDay() && d.getDate() != 1;
							}],
							// within a month
							["%b %d", function (d) {
									return d.getDate() != 1;
							}],
							// Month
							["%m-%y", function (d) {
									return d.getMonth();
							}]
					]
			};
	</script>

</head>
<body>
<!-- 右上角的悬浮 sidebar  -->
<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
   <a href="#"> 目录 </a>
   <iframe id="ha" src=" ../../global_sidebar.html" name='left' frameborder="0" scrolling="auto" width="400"  height="100%">
    您的浏览器不支持iframe，请升级
   </iframe>  
</div>

<TABLE border=0 height=600px align=left>
  <TR>
    <TD width=260px align=left valign=top style="BORDER-RIGHT: #999999 1px dashed">
      <ul id="tree" class="ztree">
        
      </ul>
    </TD>
    <TD width=770px align=left valign=top>

<!---------------------------------------------------------------------------------------------------------------------------->
<div class="container">
<span style="font-size:20px;cursor:pointer;z-index: 9999; position: fixed; right: 0px; top: 0px;" onclick="openNav()">&#9776; 目录</span>
 
<h1 id="_1">链接</h1>
<hr />
<blockquote>
<p>牛客OJ：<a href="http://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">栈的压入、弹出序列</a></p>
<p>九度OJ：http://ac.jobdu.com/problem.php?pid=1366</p>
<p>GitHub代码： <a href="https://github.com/gatieme/CodingInterviews/tree/master/022-栈的压入弹出序列">022-栈的压入弹出序列</a></p>
<p>CSDN题解：<a href="http://blog.csdn.net/gatieme/article/details/51190653">剑指Offer--022栈的压入、弹出序列</a></p>
</blockquote>
<table style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'>
<thead>
<tr>
<th style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'>牛客OJ</th>
<th align="center">九度OJ</th>
<th align="right">CSDN题解</th>
<th align="right">GitHub代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'><a href="http://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">栈的压入、弹出序列</a></td>
<td align="center"><a href="http://ac.jobdu.com/problem.php?pid=1366">1366-栈的压入、弹出序列</a></td>
<td align="right"><a href="http://blog.csdn.net/gatieme/article/details/51190653">剑指Offer--022栈的压入、弹出序列</a></td>
<td align="right"><a href="https://github.com/gatieme/CodingInterviews/tree/master/022-栈的压入弹出序列">022-栈的压入弹出序列</a></td>
</tr>
</tbody>
</table>
<p><br><strong>您也可以选择<a href="http://blog.csdn.net/gatieme/article/details/51916802">回到目录-剑指Offer--题集目录索引</a></strong></p>
<h1 id="_2">题意</h1>
<hr />
<p><strong>题目描述</strong></p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。</p>
</blockquote>
<p>假设压入栈的所有数字均不相等。</p>
<p>例如序列1,2,3,4,5是某栈的压入顺序，</p>
<p>序列4，5,3,2,1是该压栈序列对应的一个弹出序列，</p>
<p>但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<h1 id="_3">分析</h1>
<hr />
<p>http://www.cnblogs.com/kaituorensheng/p/3618339.html
http://blog.csdn.net/htyurencaotang/article/details/9266157
http://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106
http://www.cnblogs.com/tgkx1054/archive/2012/11/13/2769014.html</p>
<h1 id="_4">辅助栈模拟入栈出栈过程</h1>
<hr />
<p>思路：</p>
<p>开辟一个辅助栈，模拟入栈出战过程(假设pa为入栈序列，pb为出战序列)</p>
<p>pa中的元素依次压入辅助栈</p>
<p>新压入的元素与弹出序列的栈底相同，辅助栈弹出，同时pb向上移动</p>
<p>不相同了pa中的元素继续入辅助</p>
<ul>
<li>
<p>如果下一个弹出的数字刚好是栈顶数字，则直接弹出。</p>
</li>
<li>
<p>若下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。</p>
</li>
<li>
<p>若所有的数字都压入栈了仍没有找到下一个弹出的数字，则表明该序列不可能滴一个弹出序列。</p>
</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using namespace std;

//  调试开关
#define __tmain main

#ifdef __tmain

#define debug cout

#else

#define debug 0 &amp;&amp; cout

#endif // __tmain


class Solution
{
public:
	bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV)
	{

		if(pushV.size( ) == 0 || popV.size( ) == 0)
		{
			return false;
		}
		stack&lt;int&gt; s;
		int push, pop;

		s.push(pushV[0]);
		debug &lt;&lt;&quot;push&quot; &lt;&lt;pushV[0] &lt;&lt;endl;

		for(push = 0, pop = 0;
			push &lt; pushV.size() &amp;&amp; pop &lt; popV.size( );)
		{
			if(s.empty( ) != true &amp;&amp; s.top( ) == popV[pop])        //  当前栈顶元素正好是出栈序列中的元素
			{
				debug &lt;&lt;&quot;pop&quot;&lt;&lt;popV[pop] &lt;&lt;endl;
				// 模拟出栈的过程
				s.pop( );
				pop++;
			}
			else
			{

				//  模拟入栈的过程
				s.push(pushV[++push]);
				debug &lt;&lt;&quot;push&quot; &lt;&lt;pushV[push] &lt;&lt;endl;

			}
		}
		if(s.empty( ) == true)
		{
			return true;
		}
		else
		{
			return false;
		}




	}
};

int __tmain( )
{
	int nPush[5] = {1,2,3,4,5};
	int nPop1[5] = {4,5,3,2,1};
	int nPop2[5] = {4,3,5,1,2};
	int nPop3[5] = {5,4,3,2,1};
	int nPop4[5] = {4,5,2,3,1};

	Solution solu;

	cout &lt;&lt;solu.IsPopOrder(vector&lt;int&gt;(nPush, nPush + 5), vector&lt;int&gt;(nPop1, nPop1 + 5)) &lt;&lt; endl;
	cout &lt;&lt;solu.IsPopOrder(vector&lt;int&gt;(nPush, nPush + 5), vector&lt;int&gt;(nPop2, nPop2 + 5)) &lt;&lt; endl;
	cout &lt;&lt;solu.IsPopOrder(vector&lt;int&gt;(nPush, nPush + 5), vector&lt;int&gt;(nPop3, nPop3 + 5)) &lt;&lt; endl;
	cout &lt;&lt;solu.IsPopOrder(vector&lt;int&gt;(nPush, nPush + 5), vector&lt;int&gt;(nPop4, nPop4 + 5)) &lt;&lt; endl;

	return 0;
}
</code></pre>

<p>我们这里用了一个辅助栈来模拟出栈入栈的过程，思路很简单很清晰，但是又没有可以优化的地方么</p>
<h1 id="pushv">用PushV入栈序列作为辅助栈</h1>
<hr />
<p>其实由于当前栈的动作是肯定超不出pushV序列的，因此我们可以直接用PushV入栈序列作为我们的模拟栈，而用top去维护入栈出栈的操作</p>
<p>这种方法时间复杂度$O(n)$，空间复杂度$O(1)$，但是要修改输入参数PushV的值</p>
<pre><code class="cpp">
class Solution
{
public:
	bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV)
	{
		if(pushV.size( ) == 0 || popV.size( ) == 0)
		{
			return false;
		}
		int top = -1, push = 0, pop = 0;

		++top;
		debug &lt;&lt;&quot;push&quot; &lt;&lt;pushV[top] &lt;&lt;endl;


		while(push &lt; pushV.size() &amp;&amp; pop &lt; popV.size( ))
		{
			if(top != -1 &amp;&amp; pushV[top] == popV[pop])        //  当前栈顶元素正好是出栈序列中的元素
			{
				debug &lt;&lt;&quot;pop&quot;&lt;&lt;popV[pop] &lt;&lt;endl;
				// 模拟出栈的过程
				top--;
				pop++;
			}
			else
			{

				//  模拟入栈的过程
				pushV[++top] = pushV[++push];
				debug &lt;&lt;&quot;push&quot; &lt;&lt;pushV[push] &lt;&lt;endl;

			}
		}
		debug &lt;&lt;top &lt;&lt;push &lt;&lt;pop &lt;&lt;endl;
		return (top == -1);
	}
};
</code></pre>

<p>或者直接使用</p>
<pre><code class="cpp">class Solution
{
public:
	bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV)
	{
		if(pushV.empty( ) || popV.empty( ) || pushV.size( )!= popV.size( ))
		{
			return false;
		}

		for(int i = 0;i &lt; pushV.size();)
		{
			if(pushV[i] == popV[0])
			{
				pushV.erase(pushV.begin( ) + i);
				popV.erase(popV.begin( ));
				i--;                                // 模拟出栈
			}
			else
			{
				i++;                                //  模拟入栈
			}
		}

		return pushV.empty( );
	}

};
</code></pre>

<h1 id="_5">发现规律</h1>
<hr />
<p>这个是看到的别人的做法</p>
<p>不一样的思路：</p>
<ol>
<li>
<p>我先取出pop序列的第一个（比如pop【3,2,4,5,1】），在push序列中找到这个位置，push【1,2,3,4,5】，</p>
</li>
<li>
<p>此时我们找到了3的位置.那么下一个pop的数字（此时的数字是2）必然是，push中3的前一个数字，或者后面的数字。否则返回False
如此循环直到最后，判断长度相等，就是弹出序列。否则返回False.</p>
</li>
</ol>
<pre><code class="py">
# -*- coding:utf-8-*-

classSolution:

	def IsPopOrder(self, pushV, popV):

		# write code here

		iflen(pushV) != len(popV):

			returnFalse

		elif len(pushV) ==0:

			returnFalse

		x = popV[0]

		ifx not in pushV:

			returnFalse

		fori in range(len(popV)):

			position = pushV.index(popV[i])

			iflen(pushV) ==1:

				ifpushV[0] == popV[i]:

					returnTrue

			try:

				ifpopV[i+1] == pushV[position-1]:

					pushV.remove(pushV[position])

				elif popV[i+1] in pushV[position:]:

					pushV.remove(pushV[position])

				else:

					returnFalse

			except IndexError:

				returnFalse

		else:

			returnTrue


</code></pre>


<hr/>
<div class="footer">
	Copyright &copy; xiaoxiyouran. All rights reserved.

</div>

</div> <!-- /container -->

<!---------------------------------------------------------------------------------------------------------------------------->

        </TD>
  </TR>
</TABLE>

<!-- 请注意，以下两个部分的代码执行是有顺序的，必须严格按照这个顺序来。另外，放在底部是为了优化界面，使加载速度更快 -->
<!-- 为了优化代码风格 -->
<script src="../../../../packages/js/jquery-1.9.1.min.js" ></script>
<script src="../../../../packages/js/bootstrap.min.js" ></script>
<script src="../../../../packages/js/highlight.min.js" ></script>
<script >hljs.initHighlightingOnLoad();</script>

<!-- 以下是为了生成文档的侧边栏 -->
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery.ztree.core-3.5.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/src/ztree_toc.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
  $('#tree').ztree_toc({
    is_auto_number : true,
    use_head_anchor: true
  });
});
//-->
</SCRIPT>

</body>
</html>
    