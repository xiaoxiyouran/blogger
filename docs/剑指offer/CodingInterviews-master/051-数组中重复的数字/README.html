
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

	<title>链接</title>
	<meta name="keywords" content="xiaoxiyouran" />
	<meta name="description" content="xiaoxiyouran's Docs" />
	<link href="../../../../packages/css/bootstrap.min.css" rel="stylesheet" />
	<link href="../../../../packages/css/style.css" rel="stylesheet" />
	<link href="../../../../packages/css/monokai_sublime.min.css" rel="stylesheet">
	
	<!-- 右上角的侧边导航栏 -->
	<link rel="stylesheet" href="../../../../packages/hock_side_bar/css/sidebar.css"> <!--初始化文件-->
	<script src="../../../../packages/hock_side_bar/js/sidebar.js"></script> <!--rem适配js-->
	
	<!--
	<link href="<?php echo $base_url?>/css/bootstrap-theme.min.css" rel="stylesheet" />
	-->
	
	<!-- To generate the side tree of the document itself. -->
  <link rel="stylesheet" href="../../../../packages/generate_header_sidebar/css/zTreeStyle/zTreeStyle.css" type="text/css">
  <style>
  body {
  background-color: white;
  margin:0; padding:0;
  // text-align: center;
  overflow: scroll;
  }
  div, p, table, th, td {
    list-style:none;
    margin:8px; padding:0;
    color:#333; font-size:12px;
   Font-family: Helvetica, Tahoma, Arial, STXihei, “华文细黑”, “Microsoft YaHei”, “微软雅黑”, SimSun, “宋体”, Heiti, “黑体”, sans-serif;
  }
  
 // table{
 //   border-collapse:collapse;
 // }

  //table, td, th{
  //  border:1px solid black;   
  //}
  
  .ztree li a.curSelectedNode {
    padding-top: 0px;
    background-color: #FFE6B0;
    color: black;
    height: 16px;
    border: 1px #FFB951 solid;
    opacity: 0.8;
  }
  .ztree{
    overflow: auto;
    height:100%;
    min-height: 200px;
    top: 0px;
  }
  </style>

<!--
  For Latex formula
-->
<!--
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"],["\(","\)"]]}
  });
</script>
-->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"]]}
  });
</script>
 <script type="text/javascript" src="../../../../packages/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>

<!-- mermaid 画图 -->
 <link rel="stylesheet" href="../../../../packages/mermaid-7.0.0/dist/mermaid.forest.css"/>
 <script src="../../../../packages/mermaid-7.0.0/dist/mermaid.js"></script>
 <script src="../../../../packages/mermaid-7.0.0/dist/dist/mermaid.full.js"></script>
 <!-- <scrpt src="../../../../packages/mermaid-7.0.0/node_modules/d3/d3.js"></scrpt> -->
 <!-- <script>mermaid.initialize({startOnLoad:true});</script>  -->
 <script>
	//browserify --entry src/mermaid.js -u d3 -o ./dist/mermaid.brow.slim.js
			var mermaid_config = {
					startOnLoad:true
			}
			mermaid.ganttConfig = {
					titleTopMargin:25,
					barHeight:20,
					barGap:4,
					topPadding:50,
					leftPadding:75,
					gridLineStartPadding:35,
					fontSize:11,
					numberSectionStyles:3,
					axisFormatter: [
							// Within a day
							["%I:%M", function (d) {
									return d.getHours();
							}],
							// Monday a week
							["w. %U", function (d) {
									return d.getDay() == 1;
							}],
							// Day within a week (not monday)
							["%a %d", function (d) {
									return d.getDay() && d.getDate() != 1;
							}],
							// within a month
							["%b %d", function (d) {
									return d.getDate() != 1;
							}],
							// Month
							["%m-%y", function (d) {
									return d.getMonth();
							}]
					]
			};
	</script>

</head>
<body>
<!-- 右上角的悬浮 sidebar  -->
<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
   <a href="#"> 目录 </a>
   <iframe id="ha" src=" ../../global_sidebar.html" name='left' frameborder="0" scrolling="auto" width="400"  height="100%">
    您的浏览器不支持iframe，请升级
   </iframe>  
</div>

<TABLE border=0 height=600px align=left>
  <TR>
    <TD width=260px align=left valign=top style="BORDER-RIGHT: #999999 1px dashed">
      <ul id="tree" class="ztree">
        
      </ul>
    </TD>
    <TD width=770px align=left valign=top>

<!---------------------------------------------------------------------------------------------------------------------------->
<div class="container">
<span style="font-size:20px;cursor:pointer;z-index: 9999; position: fixed; right: 0px; top: 0px;" onclick="openNav()">&#9776; 目录</span>
 
<h1 id="_1">链接</h1>
<hr />
<blockquote>
<p>牛客OJ：<a href="http://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">数组中重复的数字</a></p>
<p>九度OJ：未收录</p>
<p>GitHub代码： <a href="https://github.com/gatieme/CodingInterviews/tree/master/051-数组中重复的数字">051-数组中重复的数字</a></p>
<p>CSDN题解：<a href="http://blog.csdn.net/gatieme/article/details/51540159">剑指Offer--051-数组中重复的数字</a></p>
</blockquote>
<table style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'>
<thead>
<tr>
<th style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'>牛客OJ</th>
<th align="center">九度OJ</th>
<th align="right">CSDN题解</th>
<th align="right">GitHub代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style='border: 1px solid black; border-collapse:collapse;  border-spacing:0;'><a href="http://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">051-数组中重复的数字</a></td>
<td align="center">未收录</td>
<td align="right"><a href="http://blog.csdn.net/gatieme/article/details/51540159">剑指Offer--051-数组中重复的数字</a></td>
<td align="right"><a href="https://github.com/gatieme/CodingInterviews/tree/master/051-数组中重复的数字">051-数组中重复的数字</a></td>
</tr>
</tbody>
</table>
<h1 id="_2">题意</h1>
<hr />
<p><strong>题目描述</strong></p>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 </p>
<p>数组中某些数字是重复的，但不知道有几个数字是重复的。</p>
<p>也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p>
<p>例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
</blockquote>
<p><strong>样例输入</strong></p>
<blockquote>
<p>2, 3, 1, 0, 2, 5, 3</p>
<p>2, 1, 3, 1, 4</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>2</p>
<p>1</p>
</blockquote>
<h1 id="_3">检查数据的合法性</h1>
<hr />
<ul>
<li>
<p>检查输入参数是否合法</p>
</li>
<li>
<p>数组中的数据是否满足所有数字都在0到n-1的范围内</p>
</li>
</ul>
<pre><code class="cpp">bool CheckValidity(int *numbers, int length)
{
	//  输入数据不合法
	if(numbers == NULL || length &lt;= 0)
	{
		return false;
	}

	//  元素必须在[0, n-1]的范围
	for(int i = 0; i &lt; length; i++)
	{
		if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)
		{
			return false;
		}
	}

	return true;
}
</code></pre>

<h1 id="_4">排序后判断重复</h1>
<hr />
<p>最简单的思路就是先把输入的数组排序。从排序的数组中找出重复的数字就是个很容易的事情了。只需要从头向尾扫描一遍排序好的数组即可。</p>
<p>对一个数组排序的时间复杂度是$O(nlogn)$</p>
<p>扫描一个排序好的数组发现重复的数字的时间复杂度是$O(n)$</p>
<pre><code class="cpp">class Solution
{
public:
	bool duplicate(int numbers[], int length, int* duplication)
	{
		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}

		sort(numbers, numbers + length);    //  对数组进行排序

		int i = 0;
		bool isDup = false;
		*duplication = -1;

		//  扫描一遍数组发现重复的数字
		for(i = 0; i &lt; length - 1; i++)
		{
			if(numbers[i] == numbers[i + 1])    //  重复了
			{
				isDup = true;
				*duplication = numbers[i];
				break;
			}
		}

		return isDup;
	}
};

</code></pre>

<h1 id="hashtable">hashtable哈希法优化查找速率</h1>
<hr />
<p>当然我们用hashtabble也可以实现，</p>
<p>hashtable中可以很方便的查找到某个元素是否存在，时间负责度$O(n)$,空间复杂度$O(n)$</p>
<pre><code class="cpp">class Solution
{
public:
	// Parameters:
	//        numbers:     an array of integers
	//        length:      the length of array numbers
	//        duplication: (Output) the duplicated number in the array number
	// Return value:       true if the input is valid, and there are some duplications in the array number
	//                     otherwise false
	bool duplicate(int numbers[], int length, int* duplication)
	{

		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}

		set&lt;int&gt; s;
		bool isDup = false;
		*duplication = -1;
		for(int i = 0; i &lt; length; i++)
		{
			if(s.count(numbers[i]) == 1)  // 如果当前元素已经存在set中
			{
				isDup = true;
				*duplication = numbers[i];
				break;
			}
			s.insert(numbers[i]);

		}

		return isDup;
	}
};
</code></pre>

<h1 id="_5">标识数组法</h1>
<hr />
<p>hashtable的方式是在优化查找的过程，因为hashtable查找的时间复杂度为$O(1)$,</p>
<p>那么我们继而联想到，如果不设hash，直接用一个用一个数组flag当前标识，记录某个元素是否出现, </p>
<blockquote>
<p>flag[i] =0标识元素i未出现,</p>
<p>flag[i] =1标识元素i出现</p>
</blockquote>
<p>这样也可以在$O(1)$的时间内实现判断</p>
<h2 id="on">空间$O(n)$的标识数组</h2>
<hr />
<pre><code class="cpp">class Solution
{
public:
	bool duplicate(int numbers[], int length, int* duplication)
	{
		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}
		int flags[length];
		memset(flags, 0, sizeof(flags));
		for(int i = 0; i &lt; length; i++)
		{
			if(flags[numbers[i]] != 0)
			{
				*duplication = numbers[i];
				return true;
			}
			else
			{
				flags[numbers[i]] = 1;
			}
		}

		return false;
	}

};
</code></pre>

<p>我们采用了一个以空间换时间的方式, 但是有没有什么办法能够优化空间上的消耗呢?</p>
<p>因为我们需要的只是一个标识, 0或者1,那么我们完全没必要一个整数来做标识，</p>
<p>因此可做如下优化</p>
<blockquote>
<p>用一个n位的单元来存储即可, 每一位都是一个标识</p>
</blockquote>
<p>这种方法可以把空间消耗将低, 但是还是需要额外的空间，那么有没有不需要空间消耗的方法呢?</p>
<h2 id="_6">符号位标识法</h2>
<hr />
<p>我们可以看到数组中元素的大小都在[0-n)这个区间内, 都是正数，那么他们的符号位对我们来说就是无关紧要的, 因此我们直接拿符号位当成我们的标识位就行了</p>
<blockquote>
<p>numbers[i]符号位为0表示数字i没有重复</p>
<p>numbers[i]符号位为1标识数字i重复</p>
</blockquote>
<pre><code class="cpp">#define SET_SYMBOL_BIT(num)  ((num) |= (1 &lt;&lt; 31))       /*  设置符号位为1 */
#define GET_ORIGIN_NUM(num)  ((num) &amp; (~(1 &lt;&lt; 31)))     /*  获取到源数据  */
#define GET_SYMBOL_BIT(num)  (((num) &gt;&gt; 31) &amp; 1)        /*  获取符号位(标识)*/

class Solution
{
public:
	/*
		对于每一个数据numbers[i]
		其源数据origin = GET_ORIGIN_NUM(numbers[i])的标识存储在numbers[origin]的符号位
		判断其标识是否为1即可
	*/
	bool duplicate(int numbers[], int length, int* duplication)
	{
		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}
		for(int i = 0; i &lt; length; i++)
		{
			//  当前数字numbers[i]的标识即是numbers[numbers[i]]的符号位
			//  检查numbers[i]
			debug &lt;&lt;&quot;origin = &quot; &lt;&lt;GET_ORIGIN_NUM(numbers[i]) &lt;&lt;&quot;, flag = &quot; &lt;&lt;GET_SYMBOL_BIT(numbers[GET_ORIGIN_NUM(numbers[i])]) &lt;&lt;endl;
			if(GET_SYMBOL_BIT(numbers[GET_ORIGIN_NUM(numbers[i])]) == 1)
			{
				*duplication = GET_ORIGIN_NUM(numbers[i]);
				return true;
			}
			else
			{
				SET_SYMBOL_BIT(numbers[GET_ORIGIN_NUM(numbers[i])]);
				debug &lt;&lt;&quot;SET origin = &quot; &lt;&lt;GET_ORIGIN_NUM(numbers[i]) &lt;&lt;&quot;, flag = &quot; &lt;&lt;GET_SYMBOL_BIT(numbers[GET_ORIGIN_NUM(numbers[i])]) &lt;&lt;endl;
			}
		}

		return false;
	}

};
</code></pre>

<h1 id="_7">固定偏移法</h1>
<hr />
<p>跟标识法类似, 如果不借助外部辅助空间，那么我们只能在数组内部下功夫，又能设置标识，又能恢复数据（不破坏数据）的方式，前面我们用符号位作为标识的方法就是通过符号位，即判断了是否存在，又可以通过符号位的反转重新恢复数据，那么有没有其他类似的方法呢？</p>
<p>我们想到我们的数据都是[0, n)这个区间的，那么我们采用类似与移码的方法，让数据加上或者减去一个固定的偏移量，这样就可以即标识数据，又不损坏数据,为了能够区分出数据，这个偏移必须大于N，这样我们的原数据与标识数据存在一一映射关系。</p>
<blockquote>
<p>[0, n-1]  -=&gt;+偏移n-=&gt; [n, 2n-1]</p>
</blockquote>
<pre><code class="cpp">class Solution
{
public:
	// Parameters:
	//        numbers:     an array of integers
	//        length:      the length of array numbers
	//        duplication: (Output) the duplicated number in the array number
	// Return value:       true if the input is valid, and there are some duplications in the array number
	//                     otherwise false
	bool duplicate(int numbers[], int length, int* duplication)
	{
		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}

		for(int i = 0; i &lt; length; i++)
		{
			if(numbers[numbers[i] % length] &gt;= length)
			{
				*duplication = numbers[i] % length;
				return true;
			}
			else
			{
				numbers[numbers[i] % length] += length;
			}
		}

		return false;

	}
};

</code></pre>

<h1 id="_8">将元素放在自己改在的位置</h1>
<hr />
<p>剑指offer上提供的方法，这种方法采用交换的方法</p>
<p>我们考虑如果每个数字都置出现一次，那么此时是最完美的，<font color=00ff99>每一个下标i对应元素numbers[i]</font>，也就是说我们对于数组中的每个元素numbers[i]都把它放在自己应该在的位置上numbers[numbers[i]]上, 如果我们发现有两个元素想往同一个位置上放的时候，说明此元素必然重复</p>
<p>即如下的过程</p>
<ol>
<li>
<p>如果numbers[i] <mark> i, 那么我们认为number[i]这个元素是在自己的位置上的</p>
</li>
<li>
<p>否则的话, numbers[i]这个元素就应该在numbers[numbers[i]]这个位置上, 于是我们交换numbers[i]和numbers[numbers[i]]</p>
</li>
<li>
<p>重复操作1, 直到number[i]</mark> i, 则继续操作下一个位置的元素, 或者numbers[i] == numbers[numbers[i]，元素重复</p>
</li>
</ol>
<pre><code class="cpp">class Solution
{
public:
	// Parameters:
	//        numbers:     an array of integers
	//        length:      the length of array numbers
	//        duplication: (Output) the duplicated number in the array number
	// Return value:       true if the input is valid, and there are some duplications in the array number
	//                     otherwise false
	bool duplicate(int numbers[], int length, int* duplication)
	{
		*duplication = -1;

		if(CheckValidity(numbers, length) == false)
		{
			return false;
		}

		for(int i = 0; i &lt; length; i++)
		{
			// 极端情况按顺序排序, 第i个位置上的数numbers[i]应该等于其下标i
			while(numbers[i] != i)
			{
				debug &lt;&lt;&quot;numbers[&quot; &lt;&lt;i &lt;&lt;&quot;] = &quot; &lt;&lt;numbers[i] &lt;&lt;&quot; isn't equal to it's index = &quot; &lt;&lt;i &lt;&lt;endl;
				//  第numbers[i]位置上的数据numbers[numbers[i]应该是numbers[i]
				//  即数numbers[i]应该是数组第numbers[i]个数numbers[numbers[i]
				if(numbers[i] == numbers[numbers[i]])
				{
					*duplication = numbers[i];
					return true;
				}
				debug &lt;&lt;&quot;swap numbers[&quot; &lt;&lt;i &lt;&lt;&quot;] and numbers[&quot; &lt;&lt;numbers[i] &lt;&lt;&quot;]&quot; &lt;&lt;endl;
				swap(numbers[i], numbers[numbers[i]]);
			}
			debug &lt;&lt;&quot;numbers[&quot; &lt;&lt;i &lt;&lt;&quot;] = &quot; &lt;&lt;numbers[i] &lt;&lt;&quot; is equal to it's index = &quot; &lt;&lt;i &lt;&lt;endl;

		}

		return false;

	}

};

</code></pre>


<hr/>
<div class="footer">
	Copyright &copy; xiaoxiyouran. All rights reserved.

</div>

</div> <!-- /container -->

<!---------------------------------------------------------------------------------------------------------------------------->

        </TD>
  </TR>
</TABLE>

<!-- 请注意，以下两个部分的代码执行是有顺序的，必须严格按照这个顺序来。另外，放在底部是为了优化界面，使加载速度更快 -->
<!-- 为了优化代码风格 -->
<script src="../../../../packages/js/jquery-1.9.1.min.js" ></script>
<script src="../../../../packages/js/bootstrap.min.js" ></script>
<script src="../../../../packages/js/highlight.min.js" ></script>
<script >hljs.initHighlightingOnLoad();</script>

<!-- 以下是为了生成文档的侧边栏 -->
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery.ztree.core-3.5.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/src/ztree_toc.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
  $('#tree').ztree_toc({
    is_auto_number : true,
    use_head_anchor: true
  });
});
//-->
</SCRIPT>

</body>
</html>
    