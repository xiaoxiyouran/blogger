
<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

	<title>20180404_Cpp STL 里的常用算法</title>
	<meta name="keywords" content="xiaoxiyouran" />
	<meta name="description" content="xiaoxiyouran's Docs" />
	<link href="../../../../packages/css/bootstrap.min.css" rel="stylesheet" />
	<link href="../../../../packages/css/style.css" rel="stylesheet" />
	<link href="../../../../packages/css/monokai_sublime.min.css" rel="stylesheet">
	
	<!-- 右上角的侧边导航栏 -->
	<link rel="stylesheet" href="../../../../packages/hock_side_bar/css/sidebar.css"> <!--初始化文件-->
	<script src="../../../../packages/hock_side_bar/js/sidebar.js"></script> <!--rem适配js-->
	
	<!--
	<link href="<?php echo $base_url?>/css/bootstrap-theme.min.css" rel="stylesheet" />
	-->
	
	<!-- To generate the side tree of the document itself. -->
  <link rel="stylesheet" href="../../../../packages/generate_header_sidebar/css/zTreeStyle/zTreeStyle.css" type="text/css">
  <style>
  body {
  background-color: white;
  margin:0; padding:0;
  // text-align: center;
  overflow: scroll;
  }
  div, p, table, th, td {
    list-style:none;
    margin:8px; padding:0;
    color:#333; font-size:12px;
   Font-family: Helvetica, Tahoma, Arial, STXihei, “华文细黑”, “Microsoft YaHei”, “微软雅黑”, SimSun, “宋体”, Heiti, “黑体”, sans-serif;
  }
  
 // table{
 //   border-collapse:collapse;
 // }

  //table, td, th{
  //  border:1px solid black;   
  //}
  
  .ztree li a.curSelectedNode {
    padding-top: 0px;
    background-color: #FFE6B0;
    color: black;
    height: 16px;
    border: 1px #FFB951 solid;
    opacity: 0.8;
  }
  .ztree{
    overflow: auto;
    height:100%;
    min-height: 200px;
    top: 0px;
  }
  </style>

<!--
  For Latex formula
-->
<!--
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"],["\(","\)"]]}
  });
</script>
-->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [["$","$"]]}
  });
</script>
 <script type="text/javascript" src="../../../../packages/MathJax/MathJax.js?config=TeX-AMS_HTML-full"></script>

<!-- mermaid 画图 -->
 <link rel="stylesheet" href="../../../../packages/mermaid-7.0.0/dist/mermaid.forest.css"/>
 <script src="../../../../packages/mermaid-7.0.0/dist/mermaid.js"></script>
 <script src="../../../../packages/mermaid-7.0.0/dist/dist/mermaid.full.js"></script>
 <!-- <scrpt src="../../../../packages/mermaid-7.0.0/node_modules/d3/d3.js"></scrpt> -->
 <!-- <script>mermaid.initialize({startOnLoad:true});</script>  -->
 <script>
	//browserify --entry src/mermaid.js -u d3 -o ./dist/mermaid.brow.slim.js
			var mermaid_config = {
					startOnLoad:true
			}
			mermaid.ganttConfig = {
					titleTopMargin:25,
					barHeight:20,
					barGap:4,
					topPadding:50,
					leftPadding:75,
					gridLineStartPadding:35,
					fontSize:11,
					numberSectionStyles:3,
					axisFormatter: [
							// Within a day
							["%I:%M", function (d) {
									return d.getHours();
							}],
							// Monday a week
							["w. %U", function (d) {
									return d.getDay() == 1;
							}],
							// Day within a week (not monday)
							["%a %d", function (d) {
									return d.getDay() && d.getDate() != 1;
							}],
							// within a month
							["%b %d", function (d) {
									return d.getDate() != 1;
							}],
							// Month
							["%m-%y", function (d) {
									return d.getMonth();
							}]
					]
			};
	</script>

</head>
<body>
<!-- 右上角的悬浮 sidebar  -->
<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
   <a href="#"> 目录 </a>
   <iframe id="ha" src=" ../../global_sidebar.html" name='left' frameborder="0" scrolling="auto" width="400"  height="100%">
    您的浏览器不支持iframe，请升级
   </iframe>  
</div>

<TABLE border=0 height=600px align=left>
  <TR>
    <TD width=260px align=left valign=top style="BORDER-RIGHT: #999999 1px dashed">
      <ul id="tree" class="ztree">
        
      </ul>
    </TD>
    <TD width=770px align=left valign=top>

<!---------------------------------------------------------------------------------------------------------------------------->
<div class="container">
<span style="font-size:20px;cursor:pointer;z-index: 9999; position: fixed; right: 0px; top: 0px;" onclick="openNav()">&#9776; 目录</span>
 
<h1 id="20180404_cpp-stl">20180404_Cpp STL 里的常用算法</h1>
<p>转载原文： https://blog.csdn.net/tick_tock97/article/details/71316372</p>
<p>C++标准函数库中，为我们提供了一个algorithm库，里面包含了十分多的常用算法，下面我来做一个小小的总结.</p>
<p>这些函数大多都在<code>&lt;algorithm&gt;</code>库里，如果不是，会特别标出。</p>
<p><code>[first,last)</code>: 可以是数组指针的范围或者迭代器的it</p>
<h2 id="1-">1-非修改序列操作</h2>
<pre><code class="cpp">adjacent_find        查找两个相邻（Adjacent）相等（Identical）元素，返回第一对相等的。
find                 返回第一个值等价于给定值的元素
find_end             查找范围 A 中与范围 B 等价的子范围最后出现的位置
find_first_of        查找范围 A 中第一个与范围 B 中任一元素等价的元素的位置
find_if              返回第一个值满足给定条件的元素
find_if_not (C++11)  返回第一个值不满足给定条件的元素

all_of (C++11)      检测在给定范围中是否所有元素都满足给定的条件
any_of (C++11)      检测在给定范围中是否存在元素满足给定条件
none_of (C++11) 检测在给定范围中是否不存在元素满足给定的条件

count               返回值等价于给定值的元素的个数
count_if            返回值满足给定条件的元素的个数

equal               返回两个范围是否相等
mismatch            返回两个范围中第一个元素不等价的位置

for_each            对范围中的每个元素调用指定函数

search              在范围 A 中查找第一个与范围 B 等价的子范围的位置
search_n            在给定范围中查找第一个连续 n 个元素都等价于给定值的子范围的位置
</code></pre>

<h3 id="11-adjoacent_find">1.1 adjoacent_find</h3>
<pre><code class="cpp">equality (1)    
template &lt;class ForwardIterator&gt;
   ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last);
predicate (2)       // 可自定义一个比较函数  
template &lt;class ForwardIterator, class BinaryPredicate&gt;
   ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last,
								  BinaryPredicate pred);
</code></pre>

<p>查找[first, last) 这两个区间第一对重复的值，若找到，返回重复的第一个元素的迭代器。如果没有找到，返回last.</p>
<p>函数原型：</p>
<pre><code class="cpp">template &lt;class ForwardIterator&gt;
   ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last)
{
  if (first != last)
  {
	ForwardIterator next=first; ++next;
	while (next != last) {
	  if (*first == *next)     // or: if (pred(*first,*next)), for version (2)
		return first;
	  ++first; ++next;
	}
  }
  return last;
}
</code></pre>

<p>举例：</p>
<pre><code class="cpp">// adjacent_find example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::adjacent_find
#include &lt;vector&gt;       // std::vector

/// 即使传进的是迭代器
bool myfunction (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {5,20,5,30,30,20,10,10,20};
  std::vector&lt;int&gt; myvector (myints,myints+8);  ///or  myvector(myints, myints + sizeof(myints)/sizeof(myints[0]) )
  std::vector&lt;int&gt;::iterator it;

  // using default comparison:
  it = std::adjacent_find (myvector.begin(), myvector.end());

  if (it!=myvector.end())
	std::cout &lt;&lt; &quot;the first pair of repeated elements are: &quot; &lt;&lt; *it &lt;&lt; '\n';

  //using predicate comparison:
  it = std::adjacent_find (++it, myvector.end(), myfunction);

  if (it!=myvector.end())
	std::cout &lt;&lt; &quot;the second pair of repeated elements are: &quot; &lt;&lt; *it &lt;&lt; '\n';

  //---------------------------------------------------------------------------
  // 也可直接用来查找数组
  int * p;
  p = std::adjacent_find(myints,myints+6);
  if( p != myints+6 ){
	  std::cout &lt;&lt; &quot;the first pair of repeated elements are: &quot; &lt;&lt; *p &lt;&lt; std::endl;
  }
  return 0;
}

&gt;&gt;&gt;
the first pair of repeated elements are: 30
the second pair of repeated elements are: 10
the first pair of repeated elements are: 30
</code></pre>

<h3 id="12-find">1.2 find</h3>
<p>查找在[first,last) 范围内，第一个等于指定元素的迭代器，如果没有找到，返回last.</p>
<p>函数原型：</p>
<pre><code class="cpp">/// 如果T是自己定义的结构体类型，就可以自己定义一个find函数
template&lt;class InputIterator, class T&gt;
InputIterator find (InputIterator first, InputIterator last, const T&amp; val)
{
  while (first!=last) {
	if (*first==val) return first;
	++first;
  }
  return last;
}
</code></pre>

<pre><code class="cpp">// find example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::find
#include &lt;vector&gt;       // std::vector

int main () {
  // using std::find with array and pointer:
  int myints[] = { 10, 20, 30, 40 };
  int * p;

  p = std::find (myints, myints+4, 30);
  if (p != myints+4)
	std::cout &lt;&lt; &quot;Element found in myints: &quot; &lt;&lt; *p &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;Element not found in myints\n&quot;;

  // using std::find with vector and iterator:
  std::vector&lt;int&gt; myvector (myints,myints+4);
  std::vector&lt;int&gt;::iterator it;

  it = find (myvector.begin(), myvector.end(), 30);
  if (it != myvector.end())
	std::cout &lt;&lt; &quot;Element found in myvector: &quot; &lt;&lt; *it &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;Element not found in myvector\n&quot;;

  return 0;
}
&gt;&gt;&gt;
Element found in myints: 30
Element found in myvector: 30
</code></pre>

<h3 id="13-find_end">1.3 find_end</h3>
<p>第二个数组在第一个数组最后出现的位置</p>
<pre><code class="cpp">// find_end example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::find_end
#include &lt;vector&gt;       // std::vector

bool myfunction (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {1,2,3,4,5,1,2,3,4,5};
  std::vector&lt;int&gt; haystack (myints,myints+10);

  int needle1[] = {1,2,3};

  // using default comparison:
  std::vector&lt;int&gt;::iterator it;
  it = std::find_end (haystack.begin(), haystack.end(), needle1, needle1+3);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;needle1 last found at position &quot; &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';

  int needle2[] = {4,5,1};

  // using predicate comparison:
  it = std::find_end (haystack.begin(), haystack.end(), needle2, needle2+3, myfunction);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;needle2 last found at position &quot; &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
needle1 found at position 5
needle2 found at position 3
</code></pre>

<h3 id="14-find_first_of">1.4 find_first_of</h3>
<pre><code class="cpp">// find_first_of example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::find_first_of
#include &lt;vector&gt;       // std::vector
#include &lt;cctype&gt;       // std::tolower

bool comp_case_insensitive (char c1, char c2) {
  return (std::tolower(c1)==std::tolower(c2));
}

int main () {
  int mychars[] = {'a','b','c','A','B','C'};
  std::vector&lt;char&gt; haystack (mychars,mychars+6);
  std::vector&lt;char&gt;::iterator it;

  int needle[] = {'A','B','C'};

  // using default comparison:
  it = find_first_of (haystack.begin(), haystack.end(), needle, needle+3);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;The first match is: &quot; &lt;&lt; *it &lt;&lt; '\n';

  // using predicate comparison:
  it = find_first_of (haystack.begin(), haystack.end(),
					  needle, needle+3, comp_case_insensitive);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;The first match is: &quot; &lt;&lt; *it &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
The first match is: A
The first match is: a
</code></pre>

<h3 id="15-find_if">1.5 find_if</h3>
<p>按照自定义的条件在[first,last)范围内查找。如果未找到到，范围Last。</p>
<pre><code class="cpp">// find_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::find_if
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) {
  return ((i%2)==1);
}

int main () {
  std::vector&lt;int&gt; myvector;

  myvector.push_back(10);
  myvector.push_back(25);
  myvector.push_back(40);
  myvector.push_back(55);

  std::vector&lt;int&gt;::iterator it = std::find_if (myvector.begin(), myvector.end(), IsOdd);
  std::cout &lt;&lt; &quot;The first odd value is &quot; &lt;&lt; *it &lt;&lt; '\n';

  return 0;
}

&gt;&gt;&gt;
The first odd value is 25
</code></pre>

<h3 id="16-find_if_not">1.6 find_if_not</h3>
<pre><code class="cpp">// find_if_not example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::find_if_not
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,5&gt; foo = {1,2,3,4,5};

  std::array&lt;int,5&gt;::iterator it =
	std::find_if_not (foo.begin(), foo.end(), [](int i){return i%2;} );
  std::cout &lt;&lt; &quot;The first even value is &quot; &lt;&lt; *it &lt;&lt; '\n';

  return 0;
}
</code></pre>

<p>### 1.7 all_of</p>
<pre><code class="cpp">// all_of example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::all_of
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,8&gt; foo = {3,5,7,11,13,17,19,23};

  if ( std::all_of(foo.begin(), foo.end(), [](int i){return i%2;}) )
	std::cout &lt;&lt; &quot;All the elements are odd numbers.\n&quot;;

  return 0;
}

</code></pre>

<p>Output:</p>
<pre><code class="cpp">All the elements are odd numbers.
</code></pre>

<h3 id="18-any_off">1.8 any_off</h3>
<pre><code class="cpp">// any_of example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::any_of
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,7&gt; foo = {0,1,-1,3,-3,5,-5};

  if ( std::any_of(foo.begin(), foo.end(), [](int i){return i&lt;0;}) )
	std::cout &lt;&lt; &quot;There are negative elements in the range.\n&quot;;

  return 0;
}
</code></pre>

<p>Output:<code>There are negative elements in the range.</code></p>
<h3 id="19-none_of">1.9 none_of</h3>
<pre><code class="cpp">// none_of example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::none_of
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,8&gt; foo = {1,2,4,8,16,32,64,128};

  if ( std::none_of(foo.begin(), foo.end(), [](int i){return i&lt;0;}) )
	std::cout &lt;&lt; &quot;There are no negative elements in the range.\n&quot;;

  return 0;
}
</code></pre>

<h3 id="110-count">1.10 count</h3>
<p>如果没有找到，返回0</p>
<pre><code class="cpp">// count algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::count
#include &lt;vector&gt;       // std::vector

int main () {
  // counting elements in array:
  int myints[] = {10,20,30,30,20,10,10,20};   // 8 elements
  int mycount = std::count (myints, myints+8, 10);
  std::cout &lt;&lt; &quot;10 appears &quot; &lt;&lt; mycount &lt;&lt; &quot; times.\n&quot;;

  // counting elements in container:
  std::vector&lt;int&gt; myvector (myints, myints+8);
  mycount = std::count (myvector.begin(), myvector.end(), 20);
  std::cout &lt;&lt; &quot;20 appears &quot; &lt;&lt; mycount  &lt;&lt; &quot; times.\n&quot;;

  return 0;
}
&gt;&gt;&gt;
10 appears 3 times.
20 appears 3 times.
</code></pre>

<h3 id="111-count_if">1.11 count_if</h3>
<p>返回满足指定要求的元素的个数</p>
<pre><code class="cpp">// count_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::count_if
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return ((i%2)==1); }

int main () {
  std::vector&lt;int&gt; myvector;
  for (int i=1; i&lt;10; i++) myvector.push_back(i); // myvector: 1 2 3 4 5 6 7 8 9

  int mycount = count_if (myvector.begin(), myvector.end(), IsOdd);
  std::cout &lt;&lt; &quot;myvector contains &quot; &lt;&lt; mycount  &lt;&lt; &quot; odd values.\n&quot;;

  return 0;
}

&gt;&gt;&gt;
myvector contains 5 odd values.
</code></pre>

<h3 id="112-equal">1.12 equal</h3>
<pre><code class="cpp">// equal algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::equal
#include &lt;vector&gt;       // std::vector

bool mypredicate (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {20,40,60,80,100};               //   myints: 20 40 60 80 100
  std::vector&lt;int&gt;myvector (myints,myints+5);     // myvector: 20 40 60 80 100

  // using default comparison:
  if ( std::equal (myvector.begin(), myvector.end(), myints) )
	std::cout &lt;&lt; &quot;The contents of both sequences are equal.\n&quot;;
  else
	std::cout &lt;&lt; &quot;The contents of both sequences differ.\n&quot;;

  myvector[3]=81;                                 // myvector: 20 40 60 81 100

  // using predicate comparison:
  if ( std::equal (myvector.begin(), myvector.end(), myints, mypredicate) )
	std::cout &lt;&lt; &quot;The contents of both sequences are equal.\n&quot;;
  else
	std::cout &lt;&lt; &quot;The contents of both sequences differ.\n&quot;;

  return 0;
}
</code></pre>

<h3 id="113-mismatch">1.13 mismatch</h3>
<p>遍历[fir,last) 范围中的元素，找到第一组A中和B不匹配的一组元素。</p>
<pre><code class="cpp">// mismatch algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::mismatch
#include &lt;vector&gt;       // std::vector
#include &lt;utility&gt;      // std::pair

bool mypredicate (int i, int j) {
  return (i==j);
}

int main () {
  std::vector&lt;int&gt; myvector;
  for (int i=1; i&lt;6; i++) myvector.push_back (i*10); // myvector: 10 20 30 40 50

  int myints[] = {10,20,80,320,1024};                //   myints: 10 20 80 320 1024

  std::pair&lt;std::vector&lt;int&gt;::iterator,int*&gt; mypair;

  // using default comparison:
  mypair = std::mismatch (myvector.begin(), myvector.end(), myints);
  std::cout &lt;&lt; &quot;First mismatching elements: &quot; &lt;&lt; *mypair.first;
  std::cout &lt;&lt; &quot; and &quot; &lt;&lt; *mypair.second &lt;&lt; '\n';

  ++mypair.first; ++mypair.second;

  // using predicate comparison:
  mypair = std::mismatch (mypair.first, myvector.end(), mypair.second, mypredicate);
  std::cout &lt;&lt; &quot;Second mismatching elements: &quot; &lt;&lt; *mypair.first;
  std::cout &lt;&lt; &quot; and &quot; &lt;&lt; *mypair.second &lt;&lt; '\n';

  return 0;
}

&gt;&gt;&gt;
First mismatching elements: 30 and 80
Second mismatching elements: 40 and 320
</code></pre>

<h3 id="114-for_each">1.14 for_each</h3>
<p>对于每一个元素，按照函数中的方式操作。</p>
<pre><code class="cpp">// for_each example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::for_each
#include &lt;vector&gt;       // std::vector

void myfunction (int i) {  // function:
  std::cout &lt;&lt; ' ' &lt;&lt; i;
}

struct myclass {           // function object type:
  void operator() (int i) {std::cout &lt;&lt; ' ' &lt;&lt; i;}
} myobject;

int main () {
  std::vector&lt;int&gt; myvector;
  myvector.push_back(10);
  myvector.push_back(20);
  myvector.push_back(30);

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for_each (myvector.begin(), myvector.end(), myfunction);
  std::cout &lt;&lt; '\n';

  // or:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for_each (myvector.begin(), myvector.end(), myobject);
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 10 20 30
myvector contains: 10 20 30
</code></pre>

<h3 id="115-search">1.15 search</h3>
<p>和find_end 相反，在数组A中查找第一个出现子数组B的it, 未找到，返回数组A的last迭代器</p>
<pre><code class="cpp">// search algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::search
#include &lt;vector&gt;       // std::vector

bool mypredicate (int i, int j) {
  return (i==j);
}

int main () {
  std::vector&lt;int&gt; haystack;

  // set some values:        haystack: 10 20 30 40 50 60 70 80 90
  for (int i=1; i&lt;10; i++) haystack.push_back(i*10);

  // using default comparison:
  int needle1[] = {40,50,60,70};
  std::vector&lt;int&gt;::iterator it;
  it = std::search (haystack.begin(), haystack.end(), needle1, needle1+4);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;needle1 found at position &quot; &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;needle1 not found\n&quot;;

  // using predicate comparison:
  int needle2[] = {20,30,50};
  it = std::search (haystack.begin(), haystack.end(), needle2, needle2+3, mypredicate);

  if (it!=haystack.end())
	std::cout &lt;&lt; &quot;needle2 found at position &quot; &lt;&lt; (it-haystack.begin()) &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;needle2 not found\n&quot;;

  return 0;
}
Edit &amp; Run

</code></pre>

<h3 id="116-search_n">1.16 search_n</h3>
<p>找连续n个值，在容器中第一次连续出现的位置。如果没有，返回last</p>
<pre><code class="cpp">// search_n example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::search_n
#include &lt;vector&gt;       // std::vector

bool mypredicate (int i, int j) {
  return (i==j);
}

int main () {
  int myints[]={10,20,30,30,20,10,10,20};
  std::vector&lt;int&gt; myvector (myints,myints+8);

  std::vector&lt;int&gt;::iterator it;

  // using default comparison:
  it = std::search_n (myvector.begin(), myvector.end(), 2, 30);

  if (it!=myvector.end())
	std::cout &lt;&lt; &quot;two 30s found at position &quot; &lt;&lt; (it-myvector.begin()) &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;match not found\n&quot;;

  // using predicate comparison:
  it = std::search_n (myvector.begin(), myvector.end(), 2, 10, mypredicate);

  if (it!=myvector.end())
	std::cout &lt;&lt; &quot;two 10s found at position &quot; &lt;&lt; int(it-myvector.begin()) &lt;&lt; '\n';
  else
	std::cout &lt;&lt; &quot;match not found\n&quot;;

  return 0;
}
Edit &amp; Run

</code></pre>

<h2 id="2-">2- 修改序列操作</h2>
<pre><code class="cpp">copy    将一个范围中的元素拷贝到新的位置处
copy_backward   将一个范围中的元素按逆序拷贝到新的位置处
copy_if (C++11) 将一个范围中满足给定条件的元素拷贝到新的位置处
copy_n (C++11)  拷贝 n 个元素到新的位置处
fill    将一个范围的元素赋值为给定值
fill_n  将某个位置开始的 n 个元素赋值为给定值
generate    将一个函数的执行结果保存到指定范围的元素中，用于批量赋值范围中的元素
generate_n  将一个函数的执行结果保存到指定位置开始的 n 个元素中
iter_swap   交换两个迭代器（Iterator）指向的元素
move (C++11)    将一个范围中的元素移动到新的位置处
move_backward (C++11)   将一个范围中的元素按逆序移动到新的位置处
random_shuffle  随机打乱指定范围中的元素的位置
remove  将一个范围中值等价于给定值的元素删除
remove_if   将一个范围中值满足给定条件的元素删除
remove_copy 拷贝一个范围的元素，将其中值等价于给定值的元素删除
remove_copy_if  拷贝一个范围的元素，将其中值满足给定条件的元素删除
replace 将一个范围中值等价于给定值的元素赋值为新的值
replace_copy    拷贝一个范围的元素，将其中值等价于给定值的元素赋值为新的值
replace_copy_if 拷贝一个范围的元素，将其中值满足给定条件的元素赋值为新的值
replace_if  将一个范围中值满足给定条件的元素赋值为新的值
reverse 反转排序指定范围中的元素
reverse_copy    拷贝指定范围的反转排序结果
rotate  循环移动指定范围中的元素
rotate_copy 拷贝指定范围的循环移动结果
shuffle (C++11) 用指定的随机数引擎随机打乱指定范围中的元素的位置
swap    交换两个对象的值
swap_ranges 交换两个范围的元素
transform   对指定范围中的每个元素调用某个函数以改变元素的值
unique  删除指定范围中的所有连续重复元素，仅仅留下每组等值元素中的第一个元素。
unique_copy 拷贝指定范围的唯一化（参考上述的 unique）结果
</code></pre>

<h3 id="21-copy">2.1 copy</h3>
<p>将一个容器的某个范围拷贝到另一个容器的某个位置。</p>
<pre><code class="cpp">// copy algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::copy
#include &lt;vector&gt;       // std::vector

int main () {
	int myints[]={10,20,30,40,50,60,70};
	std::vector&lt;int&gt; myvector (7);

	std::vector&lt;int&gt;::iterator it = std::copy ( myints, myints+7, myvector.begin() );
	std::cout &lt;&lt; it - myvector.begin() &lt;&lt; std::endl;    /// 7,指向的是end，取不到值的

	std::cout &lt;&lt; &quot;myvector contains:&quot;;
	for (std::vector&lt;int&gt;::iterator it = myvector.begin(); it!=myvector.end(); ++it)
		std::cout &lt;&lt; ' ' &lt;&lt; *it;

	std::cout &lt;&lt; '\n';

	return 0;
}

&gt;&gt;&gt;
7
myvector contains: 10 20 30 40 50 60 70
</code></pre>

<h3 id="22-copy_backward">2.2 copy_backward</h3>
<p>注意这个是从后向前拷贝，给定的result应该是last的位置。最好拷贝不能重叠，否则会形成覆盖。建议复制前，resize一下vector容器的大小。</p>
<pre><code class="cpp">// copy_backward example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::copy_backward
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;=5; i++)
	myvector.push_back(i*10);          // myvector: 10 20 30 40 50

  myvector.resize(myvector.size()+3);  // allocate space for 3 more elements

  std::copy_backward ( myvector.begin(), myvector.begin()+5, myvector.end() );

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 10 20 30 10 20 30 40 50
</code></pre>

<h3 id="23-copy_if">2.3 copy_if</h3>
<p>将容器1中满足条件的元素的复制。</p>
<pre><code class="cpp">// copy_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::copy_if, std::distance
#include &lt;vector&gt;       // std::vector

int main () {
	std::vector&lt;int&gt; foo = {25,15,5,-5,-15};
	std::vector&lt;int&gt; bar (foo.size());

	// copy only positive numbers:
	auto it = std::copy_if (foo.begin(), foo.end(), bar.begin(), [](int i){return !(i&lt;0);} );   ///last
	std::cout &lt;&lt; it - bar.begin() &lt;&lt; std::endl;                                                 /// 代表的是size() 大小
	bar.resize(std::distance(bar.begin(),it));  // shrink container to new size

	std::cout &lt;&lt; &quot;bar contains:&quot;;
	for (int&amp; x: bar) std::cout &lt;&lt; ' ' &lt;&lt; x;
	std::cout &lt;&lt; '\n';

	return 0;
}
</code></pre>

<h3 id="24-copy_n">2.4 copy_n</h3>
<p>将fir1 开始的n个元素复制到fir2位置，如果有重叠，可能有未定义的数据</p>
<pre><code class="cpp">// copy_n algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::copy
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[]={10,20,30,40,50,60,70};
  std::vector&lt;int&gt; myvector;

  myvector.resize(7);   // allocate space for 7 elements

  std::copy_n ( myints, 7, myvector.begin() );

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it = myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;

  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="25-fill">2.5 fill</h3>
<p>将一个范围内的元素赋为指定值。</p>
<pre><code class="cpp">// fill algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::fill
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector (8);                       // myvector: 0 0 0 0 0 0 0 0

  std::fill (myvector.begin(),myvector.begin()+4,5);   // myvector: 5 5 5 5 0 0 0 0
  std::fill (myvector.begin()+3,myvector.end()-2,8);   // myvector: 5 5 5 8 8 8 0 0

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<p>给一维动态数组赋值：</p>
<pre><code class="cpp">    int * p = new int[10];
	std::fill(p,p+10,1);
	std::for_each(p,p+10,[](int i){std::cout &lt;&lt; i &lt;&lt; &quot; &quot;&lt;&lt; std::endl;});
</code></pre>

<h3 id="26-fill_n">2.6 fill_n</h3>
<pre><code class="cpp">// fill_n example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::fill_n
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector (8,10);        // myvector: 10 10 10 10 10 10 10 10

  std::fill_n (myvector.begin(),4,20);     // myvector: 20 20 20 20 10 10 10 10
  std::fill_n (myvector.begin()+3,3,33);   // myvector: 20 20 20 33 33 33 10 10

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="27-generate">2.7 generate</h3>
<pre><code class="cpp">// generate algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::generate
#include &lt;vector&gt;       // std::vector
#include &lt;ctime&gt;        // std::time
#include &lt;cstdlib&gt;      // std::rand, std::srand

// function generator:
int RandomNumber () { return (std::rand()%100); }

// class generator:
struct c_unique {
	int current;
	c_unique() {current=0;}
	int operator()() {return ++current;}
} UniqueNumber;

int main () {
	std::srand ( unsigned ( std::time(0) ) );

	std::vector&lt;int&gt; myvector (8);

	std::generate (myvector.begin(), myvector.end(), RandomNumber);

	std::cout &lt;&lt; &quot;myvector contains:&quot;;
	for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
		std::cout &lt;&lt; ' ' &lt;&lt; *it;
	std::cout &lt;&lt; '\n';

	std::generate (myvector.begin(), myvector.end(), UniqueNumber);

	std::cout &lt;&lt; &quot;myvector contains:&quot;;
	for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
		std::cout &lt;&lt; ' ' &lt;&lt; *it;
	std::cout &lt;&lt; '\n';

	return 0;
}
&gt;&gt;&gt;
myvector contains: 57 87 76 66 85 54 17 15
myvector contains: 1 2 3 4 5 6 7 8
</code></pre>

<h3 id="28-generate_n">2.8 generate_n</h3>
<p>产生以fir 开始的9 个值。</p>
<pre><code class="cpp">// generate_n example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::generate_n

int current = 0;
int UniqueNumber () { return ++current; }

int main () {
  int myarray[9];

  std::generate_n (myarray, 9, UniqueNumber);

  std::cout &lt;&lt; &quot;myarray contains:&quot;;
  for (int i=0; i&lt;9; ++i)
	std::cout &lt;&lt; ' ' &lt;&lt; myarray[i];
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myarray contains: 1 2 3 4 5 6 7 8 9
</code></pre>

<h3 id="29-iter_swap">2.9 iter_swap</h3>
<p>交换两个迭代器指向的值。</p>
<pre><code class="cpp">    int myints[]={10,20,30,40,50 };              //   myints:  10  20  30  40  50
	for(int i=0; i&lt; 4; i++){
		std::iter_swap(myints+i, myints+i+1);
	}

	std::for_each(myints,myints+5,[](int i){std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;});
&gt;&gt;&gt;
20 30 40 50 10
</code></pre>

<p>举例</p>
<pre><code class="cpp">// iter_swap example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::iter_swap
#include &lt;vector&gt;       // std::vector

int main () {

  int myints[]={10,20,30,40,50 };              //   myints:  10  20  30  40  50
  std::vector&lt;int&gt; myvector (4,99);            // myvector:  99  99  99  99

  std::iter_swap(myints,myvector.begin());     //   myints: [99] 20  30  40  50
											   // myvector: [10] 99  99  99

  std::iter_swap(myints+3,myvector.begin()+2); //   myints:  99  20  30 [99] 50
											   // myvector:  10  99 [40] 99

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 10 99 40 99
</code></pre>

<h3 id="210-move">2.10 move</h3>
<p>move 使用移动语义，将一个对象移动一个新的位置，原来的所有权应该被销毁。</p>
<p>通常是一个函数返回的临时对象或者显示的调用构造函数。</p>
<pre><code class="cpp">/ move example
#include &lt;utility&gt;      // std::move
#include &lt;iostream&gt;     // std::cout
#include &lt;vector&gt;       // std::vector
#include &lt;string&gt;       // std::string

int main () {
  std::string foo = &quot;foo-string&quot;;
  std::string bar = &quot;bar-string&quot;;
  std::vector&lt;std::string&gt; myvector;

  myvector.push_back (foo);                    // copies
  myvector.push_back (std::move(bar));         // moves

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::string&amp; x:myvector) std::cout &lt;&lt; ' ' &lt;&lt; x;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<pre><code class="cpp">myvector contains: foo-string bar-string
</code></pre>

<h3 id="211-move_backward">2.11  move_backward</h3>
<p>把[first,last) 移动到[x, last2) 的位置，也就是last移动到last2的位置。最后才是first 移动到x的位置。</p>
<pre><code class="cpp">// move_backward example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::move_backward
#include &lt;string&gt;       // std::string

int main () {
	std::string elems[10] = {&quot;air&quot;, &quot;water&quot;, &quot;fire&quot;, &quot;earth&quot;};

	// insert new element at the beginning:
	auto it = std::move_backward(elems, elems + 4, elems + 5);
	std::cout &lt;&lt; std::distance(elems, it) &lt;&lt; std::endl;     /// 1 的位置。
	elems[0] = &quot;ether&quot;;

	std::cout &lt;&lt; &quot;elems contains:&quot;;
	for (int i = 0; i &lt; 10; ++i)
		std::cout &lt;&lt; &quot; [&quot; &lt;&lt; elems[i] &lt;&lt; &quot;]&quot;;
	std::cout &lt;&lt; '\n';

	return 0;
}

&gt;&gt;&gt;
1
elems contains: [ether] [air] [water] [fire] [earth] [] [] [] [] []

</code></pre>

<h3 id="212-random_shuffle">2.12 random_shuffle</h3>
<p>随机打乱容器内的顺序</p>
<pre><code class="cpp">// random_shuffle example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::random_shuffle
#include &lt;vector&gt;       // std::vector
#include &lt;ctime&gt;        // std::time
#include &lt;cstdlib&gt;      // std::rand, std::srand

// random generator function:
int myrandom (int i) { return std::rand()%i;}

int main () {
  std::srand ( unsigned ( std::time(0) ) );
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9

  // using built-in random generator:
  std::random_shuffle ( myvector.begin(), myvector.end() );

  // using myrandom:
  std::random_shuffle ( myvector.begin(), myvector.end(), myrandom);

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;

  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="213-remove">2.13 remove</h3>
<p>移除在[fir,last) 范围内所有等于val值的元素，最后返回移除后的last。容器的大小并未减小，要移除的值被后面的值覆盖。</p>
<pre><code class="cpp">// remove algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::remove

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};      // 10 20 30 30 20 10 10 20

  // bounds of range:
  int* pbegin = myints;                          // ^
  int* pend = myints+sizeof(myints)/sizeof(int); // ^                       ^

  pend = std::remove (pbegin, pend, 20);         // 10 30 30 10 10 ?  ?  ?
												 // ^              ^
  std::cout &lt;&lt; &quot;range contains:&quot;;
  for (int* p=pbegin; p!=pend; ++p)
	std::cout &lt;&lt; ' ' &lt;&lt; *p;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="214-remove_if">2.14 remove_if</h3>
<p>把满足条件的值去掉，但是并没有改变容器的大小，只是返回新容器的末尾指针。</p>
<pre><code class="cpp">// remove_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::remove_if

bool IsOdd (int i) { return ((i%2)==1); }

int main () {
  int myints[] = {1,2,3,4,5,6,7,8,9};            // 1 2 3 4 5 6 7 8 9

  // bounds of range:
  int* pbegin = myints;                          // ^
  int* pend = myints+sizeof(myints)/sizeof(int); // ^                 ^

  pend = std::remove_if (pbegin, pend, IsOdd);   // 2 4 6 8 ? ? ? ? ?
												 // ^       ^
  std::cout &lt;&lt; &quot;the range contains:&quot;;
  for (int* p=pbegin; p!=pend; ++p)
	std::cout &lt;&lt; ' ' &lt;&lt; *p;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
the range contains: 2 4 6 8
</code></pre>

<h3 id="215remove_copy">2.15remove_copy</h3>
<h3 id="216-remove_copy_if">2.16 remove_copy_if</h3>
<pre><code class="cpp">// remove_copy_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::remove_copy_if
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return ((i%2)==1); }

int main () {
  int myints[] = {1,2,3,4,5,6,7,8,9};
  std::vector&lt;int&gt; myvector (9);

  std::remove_copy_if (myints,myints+9,myvector.begin(),IsOdd);

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
》》》
myvector contains: 2 4 6 8 0 0 0 0 0

</code></pre>

<h3 id="217-replace">2.17 replace</h3>
<pre><code class="cpp">// replace algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::replace
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[] = { 10, 20, 30, 30, 20, 10, 10, 20 };
  std::vector&lt;int&gt; myvector (myints, myints+8);            // 10 20 30 30 20 10 10 20

  std::replace (myvector.begin(), myvector.end(), 20, 99); // 10 99 30 30 99 10 10 99

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
》》》
myvector contains: 10 99 30 30 99 10 10 99

</code></pre>

<h3 id="218-replace_if">2.18 replace_if</h3>
<pre><code class="cpp">// replace_if example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::replace_if
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return ((i%2)==1); }

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; i++) myvector.push_back(i);               // 1 2 3 4 5 6 7 8 9

  std::replace_if (myvector.begin(), myvector.end(), IsOdd, 0); // 0 2 0 4 0 6 0 8 0

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}

》》》
myvector contains: 0 2 0 4 0 6 0 8 0
</code></pre>

<h3 id="219-reverse">2.19 reverse</h3>
<p>反转[fir,last)之间的元素。首尾依次对换</p>
<pre><code class="cpp">// reverse algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::reverse
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i);   // 1 2 3 4 5 6 7 8 9

  std::reverse(myvector.begin(),myvector.end());    // 9 8 7 6 5 4 3 2 1

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
》》》
myvector contains: 9 8 7 6 5 4 3 2 1
</code></pre>

<h3 id="220-reverse_copy">2.20 reverse_copy</h3>
<pre><code class="cpp">// reverse_copy example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::reverse_copy
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[] ={1,2,3,4,5,6,7,8,9};
  std::vector&lt;int&gt; myvector;

  myvector.resize(9);    // allocate space

  std::reverse_copy (myints, myints+9, myvector.begin());

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;

  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;\
Output:
myvector contains: 9 8 7 6 5 4 3 2 1

</code></pre>

<h3 id="221-rotate">2.21 rotate</h3>
<p>以指定位置，循环移动</p>
<pre><code class="cpp">// rotate algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::rotate
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9

  std::rotate(myvector.begin(),myvector.begin()+3,myvector.end());
												  // 4 5 6 7 8 9 1 2 3
  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 4 5 6 7 8 9 1 2 3
</code></pre>

<h3 id="222-rotate_copy">2.22 rotate_copy</h3>
<pre><code class="cpp">// rotate_copy algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::rotate_copy
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[] = {10,20,30,40,50,60,70};

  std::vector&lt;int&gt; myvector (7);

  std::rotate_copy(myints,myints+3,myints+7,myvector.begin());

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
》》》
Output:
myvector contains: 40 50 60 70 10 20 30

</code></pre>

<h3 id="223-shuffle">2.23 shuffle</h3>
<pre><code class="cpp">// shuffle algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::shuffle
#include &lt;array&gt;        // std::array
#include &lt;random&gt;       // std::default_random_engine
#include &lt;chrono&gt;       // std::chrono::system_clock

int main () {
  std::array&lt;int,5&gt; foo {1,2,3,4,5};

  // obtain a time-based seed:
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();

  shuffle (foo.begin(), foo.end(), std::default_random_engine(seed));

  std::cout &lt;&lt; &quot;shuffled elements:&quot;;
  for (int&amp; x: foo) std::cout &lt;&lt; ' ' &lt;&lt; x;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
Possible output:
shuffled elements: 3 1 4 2 5
</code></pre>

<h3 id="224-swap">2.24 swap</h3>
<pre><code class="cpp">/ swap algorithm example (C++11)
#include &lt;iostream&gt;     // std::cout
#include &lt;utility&gt;      // std::swap

int main () {

  int x=10, y=20;                  // x:10 y:20
  std::swap(x,y);                  // x:20 y:10

  int foo[4];                      // foo: ?  ?  ?  ?
  int bar[] = {10,20,30,40};       // foo: ?  ?  ?  ?    bar: 10 20 30 40
  std::swap(foo,bar);              // foo: 10 20 30 40   bar: ?  ?  ?  ?

  std::cout &lt;&lt; &quot;foo contains:&quot;;
  for (int i: foo) std::cout &lt;&lt; ' ' &lt;&lt; i;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
Output:
foo contains: 10 20 30 40

</code></pre>

<h3 id="225-swap_ranges">2.25 swap_ranges</h3>
<p>交换两个范围内的元素。</p>
<pre><code class="cpp">// swap_ranges example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::swap_ranges
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; foo (5,10);        // foo: 10 10 10 10 10
  std::vector&lt;int&gt; bar (5,33);        // bar: 33 33 33 33 33

  std::swap_ranges(foo.begin()+1, foo.end()-1, bar.begin());

  // print out results of swap:
  std::cout &lt;&lt; &quot;foo contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=foo.begin(); it!=foo.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  std::cout &lt;&lt; &quot;bar contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=bar.begin(); it!=bar.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;

foo contains: 10 33 33 33 10
bar contains: 10 10 10 33 33
</code></pre>

<h3 id="226-transform">2.26 transform</h3>
<pre><code class="cpp">// transform algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::transform
#include &lt;vector&gt;       // std::vector
#include &lt;functional&gt;   // std::plus

int op_increase (int i) { return ++i; }

int main () {
  std::vector&lt;int&gt; foo;
  std::vector&lt;int&gt; bar;

  // set some values:
  for (int i=1; i&lt;6; i++)
	foo.push_back (i*10);                         // foo: 10 20 30 40 50

  bar.resize(foo.size());                         // allocate space

  std::transform (foo.begin(), foo.end(), bar.begin(), op_increase);
												  // bar: 11 21 31 41 51

  // std::plus adds together its two arguments:
  std::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), std::plus&lt;int&gt;());
												  // foo: 21 41 61 81 101

  std::cout &lt;&lt; &quot;foo contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=foo.begin(); it!=foo.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
foo contains: 21 41 61 81 101

</code></pre>

<h3 id="227-unique">2.27 unique</h3>
<pre><code class="cpp">// unique algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::unique, std::distance
#include &lt;vector&gt;       // std::vector

bool myfunction (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {10,20,20,20,30,30,20,20,10};           // 10 20 20 20 30 30 20 20 10
  std::vector&lt;int&gt; myvector (myints,myints+9);

  // using default comparison:
  std::vector&lt;int&gt;::iterator it;
  it = std::unique (myvector.begin(), myvector.end());   // 10 20 30 20 10 ?  ?  ?  ?
														 //                ^

  myvector.resize( std::distance(myvector.begin(),it) ); // 10 20 30 20 10

  // using predicate comparison:
  std::unique (myvector.begin(), myvector.end(), myfunction);   // (no changes)

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 10 20 30 20 10

</code></pre>

<h3 id="228-unique_copy">2.28 unique_copy</h3>
<pre><code class="cpp">// unique_copy example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::unique_copy, std::sort, std::distance
#include &lt;vector&gt;       // std::vector

bool myfunction (int i, int j) {
  return (i==j);
}

int main () {
  int myints[] = {10,20,20,20,30,30,20,20,10};
  std::vector&lt;int&gt; myvector (9);                            // 0  0  0  0  0  0  0  0  0

  // using default comparison:
  std::vector&lt;int&gt;::iterator it;
  it=std::unique_copy (myints,myints+9,myvector.begin());   // 10 20 30 20 10 0  0  0  0
															//                ^

  std::sort (myvector.begin(),it);                          // 10 10 20 20 30 0  0  0  0
															//                ^

  // using predicate comparison:
  it=std::unique_copy (myvector.begin(), it, myvector.begin(), myfunction);
															// 10 20 30 20 30 0  0  0  0
															//          ^

  myvector.resize( std::distance(myvector.begin(),it) );    // 10 20 30

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
vmyvector contains: 10 20 30
</code></pre>

<h2 id="3-">3- 划分</h2>
<pre><code class="cpp">is_partitioned (C++11)  检测某个范围是否按指定谓词（Predicate）划分过
partition   将某个范围划分为两组
partition_copy (C++11)  拷贝指定范围的划分结果
partition_point (C++11) 返回被划分范围的划分点
stable_partition    稳定划分，两组元素各维持相对顺序
</code></pre>

<h3 id="31-is_partitioned">3.1 is_partitioned</h3>
<pre><code class="cpp">// is_partitioned example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_partitioned
#include &lt;array&gt;        // std::array

bool IsOdd (int i) { return (i%2)==1; }

int main () {
	std::array&lt;int,7&gt; foo {1,2,3,4,5,6,7};

	// print contents:
	std::cout &lt;&lt; &quot;foo:&quot;; for (int&amp; x:foo) std::cout &lt;&lt; ' ' &lt;&lt; x;
	if ( std::is_partitioned(foo.begin(),foo.end(),IsOdd) )
		std::cout &lt;&lt; &quot; (partitioned)\n&quot;;
	else
		std::cout &lt;&lt; &quot; (not partitioned)\n&quot;;

	// partition array:
	std::partition (foo.begin(),foo.end(),IsOdd);

	// print contents again:
	std::cout &lt;&lt; &quot;foo:&quot;; for (int&amp; x:foo) std::cout &lt;&lt; ' ' &lt;&lt; x;
	if ( std::is_partitioned(foo.begin(),foo.end(),IsOdd) )
		std::cout &lt;&lt; &quot; (partitioned)\n&quot;;
	else
		std::cout &lt;&lt; &quot; (not partitioned)\n&quot;;

	return 0;
}
&gt;&gt;&gt;
foo: 1 2 3 4 5 6 7 (not partitioned)
foo: 1 7 3 5 4 6 2 (partitioned)
</code></pre>

<h3 id="32-partition">3.2 partition</h3>
<pre><code class="cpp">// partition algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::partition
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return (i%2)==1; }

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9

  std::vector&lt;int&gt;::iterator bound;
  bound = std::partition (myvector.begin(), myvector.end(), IsOdd);

  // print out content:
  std::cout &lt;&lt; &quot;odd elements:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  std::cout &lt;&lt; &quot;even elements:&quot;;
  for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
odd elements: 1 9 3 7 5
even elements: 6 4 8 2

</code></pre>

<h3 id="33-partition_copy">3.3 partition_copy</h3>
<pre><code class="cpp">// partition_copy example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::partition_copy, std::count_if
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return (i%2)==1; }

int main () {
  std::vector&lt;int&gt; foo {1,2,3,4,5,6,7,8,9};
  std::vector&lt;int&gt; odd, even;

  // resize vectors to proper size:
  unsigned n = std::count_if (foo.begin(), foo.end(), IsOdd);
  odd.resize(n); even.resize(foo.size()-n);

  // partition:
  std::partition_copy (foo.begin(), foo.end(), odd.begin(), even.begin(), IsOdd);

  // print contents:
  std::cout &lt;&lt; &quot;odd: &quot;;  for (int&amp; x:odd)  std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;even: &quot;; for (int&amp; x:even) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n';

  return 0;
}

&gt;&gt;&gt;
odd: 1 3 5 7 9
even: 2 4 6 8
</code></pre>

<h3 id="34-partition_point">3.4 partition_point</h3>
<pre><code class="cpp">// partition_point example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::partition, std::partition_point
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return (i%2)==1; }

int main () {
  std::vector&lt;int&gt; foo {1,2,3,4,5,6,7,8,9};
  std::vector&lt;int&gt; odd;

  std::partition (foo.begin(),foo.end(),IsOdd);

  auto it = std::partition_point(foo.begin(),foo.end(),IsOdd);
  odd.assign (foo.begin(),it);

  // print contents of odd:
  std::cout &lt;&lt; &quot;odd:&quot;;
  for (int&amp; x:odd) std::cout &lt;&lt; ' ' &lt;&lt; x;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="35-stable_partition">3.5 stable_partition</h3>
<pre><code class="cpp">// stable_partition example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::stable_partition
#include &lt;vector&gt;       // std::vector

bool IsOdd (int i) { return (i%2)==1; }

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9

  std::vector&lt;int&gt;::iterator bound;
  bound = std::stable_partition (myvector.begin(), myvector.end(), IsOdd);

  // print out content:
  std::cout &lt;&lt; &quot;odd elements:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=bound; ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  std::cout &lt;&lt; &quot;even elements:&quot;;
  for (std::vector&lt;int&gt;::iterator it=bound; it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
odd elements: 1 3 5 7 9
even elements: 2 4 6 8
</code></pre>

<h2 id="4-">4- 排序</h2>
<pre><code class="cpp">is_sorted (C++11)   检测指定范围是否已排序
is_sorted_until (C++11) 返回最大已排序子范围
nth_element 部份排序指定范围中的元素，使得范围按给定位置处的元素划分
partial_sort    部份排序
partial_sort_copy   拷贝部分排序的结果
sort    排序（快速排序）
stable_sort 稳定排序
</code></pre>

<h3 id="41-is_sorted">4.1 is_sorted</h3>
<pre><code class="cpp">// is_sorted example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_sorted, std::prev_permutation
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,4&gt; foo {2,4,1,3};

  do {
	// try a new permutation:
	std::prev_permutation(foo.begin(),foo.end());

	// print range:
	std::cout &lt;&lt; &quot;foo:&quot;;
	for (int&amp; x:foo) std::cout &lt;&lt; ' ' &lt;&lt; x;
	std::cout &lt;&lt; '\n';

  } while (!std::is_sorted(foo.begin(),foo.end()));

  std::cout &lt;&lt; &quot;the range is sorted!\n&quot;;

  return 0;
}
&gt;&gt;&gt;
foo: 2 3 4 1
foo: 2 3 1 4
foo: 2 1 4 3
foo: 2 1 3 4
foo: 1 4 3 2
foo: 1 4 2 3
foo: 1 3 4 2
foo: 1 3 2 4
foo: 1 2 4 3
foo: 1 2 3 4
the range is sorted!
</code></pre>

<h3 id="42-is_sorted_until">4.2 is_sorted_until</h3>
<pre><code class="cpp">// is_sorted_until example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_sorted_until, std::prev_permutation
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,4&gt; foo {2,4,1,3};
  std::array&lt;int,4&gt;::iterator it;

  do {
	// try a new permutation:
	std::prev_permutation(foo.begin(),foo.end());

	// print range:
	std::cout &lt;&lt; &quot;foo:&quot;;
	for (int&amp; x:foo) std::cout &lt;&lt; ' ' &lt;&lt; x;
	it=std::is_sorted_until(foo.begin(),foo.end());
	std::cout &lt;&lt; &quot; (&quot; &lt;&lt; (it-foo.begin()) &lt;&lt; &quot; elements sorted)\n&quot;;

  } while (it!=foo.end());

  std::cout &lt;&lt; &quot;the range is sorted!\n&quot;;

  return 0;
}
&gt;&gt;&gt;
foo: 2 3 4 1 (3 elements sorted)
foo: 2 3 1 4 (2 elements sorted)
foo: 2 1 4 3 (1 elements sorted)
foo: 2 1 3 4 (1 elements sorted)
foo: 1 4 3 2 (2 elements sorted)
foo: 1 4 2 3 (2 elements sorted)
foo: 1 3 4 2 (3 elements sorted)
foo: 1 3 2 4 (2 elements sorted)
foo: 1 2 4 3 (3 elements sorted)
foo: 1 2 3 4 (4 elements sorted)
the range is sorted!
</code></pre>

<h3 id="43-nth_element">4.3 nth_element</h3>
<pre><code class="cpp">// nth_element example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::nth_element, std::random_shuffle
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; i++) myvector.push_back(i);   // 1 2 3 4 5 6 7 8 9

  std::random_shuffle (myvector.begin(), myvector.end());

  // using default comparison (operator &lt;):
  std::nth_element (myvector.begin(), myvector.begin()+5, myvector.end());

  // using function as comp
  std::nth_element (myvector.begin(), myvector.begin()+5, myvector.end(),myfunction);

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 3 1 4 2 5 6 9 7 8
</code></pre>

<h3 id="44-partial_sort">4.4 partial_sort</h3>
<pre><code class="cpp">// partial_sort example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::partial_sort
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

int main () {
  int myints[] = {9,8,7,6,5,4,3,2,1};
  std::vector&lt;int&gt; myvector (myints, myints+9);

  // using default comparison (operator &lt;):
  std::partial_sort (myvector.begin(), myvector.begin()+5, myvector.end());

  // using function as comp
  std::partial_sort (myvector.begin(), myvector.begin()+5, myvector.end(),myfunction);

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;
myvector contains: 1 2 3 4 5 9 8 7 6
</code></pre>

<h3 id="45-partial_sort_copy">4.5 partial_sort_copy</h3>
<pre><code class="cpp">// partial_sort_copy example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::partial_sort_copy
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

int main () {
  int myints[] = {9,8,7,6,5,4,3,2,1};
  std::vector&lt;int&gt; myvector (5);

  // using default comparison (operator &lt;):
  std::partial_sort_copy (myints, myints+9, myvector.begin(), myvector.end());

  // using function as comp
  std::partial_sort_copy (myints, myints+9, myvector.begin(), myvector.end(), myfunction);

  // print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
myvector contains: 1 2 3 4 5
</code></pre>

<h3 id="46-stable_sort">4.6 stable_sort</h3>
<pre><code class="cpp">// stable_sort example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::stable_sort
#include &lt;vector&gt;       // std::vector

bool compare_as_ints (double i,double j)
{
  return (int(i)&lt;int(j));
}

int main () {
  double mydoubles[] = {3.14, 1.41, 2.72, 4.67, 1.73, 1.32, 1.62, 2.58};

  std::vector&lt;double&gt; myvector;

  myvector.assign(mydoubles,mydoubles+8);

  std::cout &lt;&lt; &quot;using default comparison:&quot;;
  std::stable_sort (myvector.begin(), myvector.end());
  for (std::vector&lt;double&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  myvector.assign(mydoubles,mydoubles+8);

  std::cout &lt;&lt; &quot;using 'compare_as_ints' :&quot;;
  std::stable_sort (myvector.begin(), myvector.end(), compare_as_ints);
  for (std::vector&lt;double&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
using default comparison: 1.32 1.41 1.62 1.73 2.58 2.72 3.14 4.67
using 'compare_as_ints' : 1.41 1.73 1.32 1.62 2.72 2.58 3.14 4.67
</code></pre>

<h2 id="5-"><strong>5</strong>- 二分法查找（用于已划分/已排序的序列）</h2>
<pre><code class="cpp">binary_search   判断范围中是否存在值等价于给定值的元素
equal_range 返回范围中值等于给定值的元素组成的子范围
lower_bound 返回指向范围中第一个值大于或等于给定值的元素的迭代器
upper_bound 返回指向范围中第一个值大于给定值的元素的迭代器
</code></pre>

<h3 id="51-binary_search">5.1 binary_search</h3>
<p>先排序，后查找。</p>
<pre><code class="cpp">// binary_search example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::binary_search, std::sort
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

int main () {
  int myints[] = {1,2,3,4,5,4,3,2,1};
  std::vector&lt;int&gt; v(myints,myints+9);                         // 1 2 3 4 5 4 3 2 1

  // using default comparison:
  std::sort (v.begin(), v.end());

  std::cout &lt;&lt; &quot;looking for a 3... &quot;;
  if (std::binary_search (v.begin(), v.end(), 3))
	std::cout &lt;&lt; &quot;found!\n&quot;; else std::cout &lt;&lt; &quot;not found.\n&quot;;

  // using myfunction as comp:
  std::sort (v.begin(), v.end(), myfunction);

  std::cout &lt;&lt; &quot;looking for a 6... &quot;;
  if (std::binary_search (v.begin(), v.end(), 6, myfunction))
	std::cout &lt;&lt; &quot;found!\n&quot;; else std::cout &lt;&lt; &quot;not found.\n&quot;;

  return 0;
}
&gt;&gt;&gt;
looking for a 3... found!
looking for a 6... not found.
</code></pre>

<h3 id="52-equal_range">5.2 equal_range</h3>
<pre><code class="cpp">// equal_range example
// equal_range example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::equal_range, std::sort
#include &lt;vector&gt;       // std::vector

bool mygreater (int i,int j) { return (i&gt;j); }

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector&lt;int&gt; v(myints,myints+8);                         // 10 20 30 30 20 10 10 20
  std::pair&lt;std::vector&lt;int&gt;::iterator,std::vector&lt;int&gt;::iterator&gt; bounds;

  // using default comparison:
  std::sort (v.begin(), v.end());                              // 10 10 10 20 20 20 30 30
  bounds=std::equal_range (v.begin(), v.end(), 20);            //          ^        ^

  // using &quot;mygreater&quot; as comp:
  std::sort (v.begin(), v.end(), mygreater);                   // 30 30 20 20 20 10 10 10
  bounds=std::equal_range (v.begin(), v.end(), 20, mygreater); //       ^        ^

  std::cout &lt;&lt; &quot;bounds at positions &quot; &lt;&lt; (bounds.first - v.begin());
  std::cout &lt;&lt; &quot; and &quot; &lt;&lt; (bounds.second - v.begin()) &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="53-lower_bound">5.3 lower_bound</h3>
<pre><code class="cpp">// lower_bound/upper_bound example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20

  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

  std::vector&lt;int&gt;::iterator low,up;
  low=std::lower_bound (v.begin(), v.end(), 20); //          ^
  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^

  std::cout &lt;&lt; &quot;lower_bound at position &quot; &lt;&lt; (low- v.begin()) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;upper_bound at position &quot; &lt;&lt; (up - v.begin()) &lt;&lt; '\n';

  return 0;
}
</code></pre>

<pre><code class="cpp">lower_bound at position 3
upper_bound at position 6
</code></pre>

<h3 id="54-upper_bound">5.4 upper_bound</h3>
<pre><code class="cpp">// lower_bound/upper_bound example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::lower_bound, std::upper_bound, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector&lt;int&gt; v(myints,myints+8);           // 10 20 30 30 20 10 10 20

  std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

  std::vector&lt;int&gt;::iterator low,up;
  low=std::lower_bound (v.begin(), v.end(), 20); //          ^
  up= std::upper_bound (v.begin(), v.end(), 20); //                   ^

  std::cout &lt;&lt; &quot;lower_bound at position &quot; &lt;&lt; (low- v.begin()) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;upper_bound at position &quot; &lt;&lt; (up - v.begin()) &lt;&lt; '\n';

  return 0;
}
</code></pre>

<p>输出结果如下：</p>
<pre><code class="cpp">lower_bound at position 3
upper_bound at position 6
</code></pre>

<h2 id="6-">6- 合并（用于已排序的序列）</h2>
<pre><code class="cpp">includes    判断一个集合是否是另一个集合的子集
inplace_merge   就绪合并
merge   合并
set_difference  获得两个集合的差集
set_intersection    获得两个集合的交集
set_symmetric_difference    获得两个集合的对称差
set_union   获得两个集合的并集
</code></pre>

<h3 id="61-includes">6.1 includes</h3>
<pre><code class="cpp">// includes algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::includes, std::sort

bool myfunction (int i, int j) { return i&lt;j; }

int main () {
  int container[] = {5,10,15,20,25,30,35,40,45,50};
  int continent[] = {40,30,20,10};

  std::sort (container,container+10);
  std::sort (continent,continent+4);

  // using default comparison:
  if ( std::includes(container,container+10,continent,continent+4) )
	std::cout &lt;&lt; &quot;container includes continent!\n&quot;;

  // using myfunction as comp:
  if ( std::includes(container,container+10,continent,continent+4, myfunction) )
	std::cout &lt;&lt; &quot;container includes continent!\n&quot;;

  return 0;
}
</code></pre>

<p>结果如下：</p>
<pre><code class="cpp">container includes continent!
container includes continent!
</code></pre>

<h3 id="62-inplace_merge">6.2 inplace_merge</h3>
<pre><code class="cpp">// inplace_merge example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::inplace_merge, std::sort, std::copy
#include &lt;vector&gt;       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int&gt; v(10);
  std::vector&lt;int&gt;::iterator it;

  std::sort (first,first+5);
  std::sort (second,second+5);

  it=std::copy (first, first+5, v.begin());
	 std::copy (second,second+5,it);

  std::inplace_merge (v.begin(),v.begin()+5,v.end());

  std::cout &lt;&lt; &quot;The resulting vector contains:&quot;;
  for (it=v.begin(); it!=v.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
&gt;&gt;&gt;
The resulting vector contains: 5 10 10 15 20 20 25 30 40 50
</code></pre>

<h3 id="63-merge">6.3 merge</h3>
<pre><code class="cpp">// merge algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::merge, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int&gt; v(10);

  std::sort (first,first+5);
  std::sort (second,second+5);
  std::merge (first,first+5,second,second+5,v.begin());

  std::cout &lt;&lt; &quot;The resulting vector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it=v.begin(); it!=v.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="64-set_difference">6.4  set_difference</h3>
<pre><code class="cpp">// set_difference example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::set_difference, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
	int first[] = {5,10,15,20,25};
	int second[] = {50,40,30,20,10};
	std::vector&lt;int&gt; v(10);                      // 0  0  0  0  0  0  0  0  0  0
	std::vector&lt;int&gt;::iterator it;

	std::sort (first,first+5);     //  5 10 15 20 25
	std::sort (second,second+5);   // 10 20 30 40 50

	it=std::set_difference (first, first+5, second, second+5, v.begin());
	//  5 15 25  0  0  0  0  0  0  0
	v.resize(it-v.begin());                      //  5 15 25

	std::cout &lt;&lt; &quot;The difference has &quot; &lt;&lt; (v.size()) &lt;&lt; &quot; elements:\n&quot;;
	for (it=v.begin(); it!=v.end(); ++it)
		std::cout &lt;&lt; ' ' &lt;&lt; *it;
	std::cout &lt;&lt; '\n';

	return 0;
}

</code></pre>

<h3 id="65-set_intersection">6.5 set_intersection</h3>
<pre><code class="cpp">// set_intersection example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::set_intersection, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int&gt; v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector&lt;int&gt;::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_intersection (first, first+5, second, second+5, v.begin());
											   // 10 20 0  0  0  0  0  0  0  0
  v.resize(it-v.begin());                      // 10 20

  std::cout &lt;&lt; &quot;The intersection has &quot; &lt;&lt; (v.size()) &lt;&lt; &quot; elements:\n&quot;;
  for (it=v.begin(); it!=v.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="66-set_symmetric_difference">6.6 set_symmetric_difference</h3>
<pre><code class="cpp">// set_symmetric_difference example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::set_symmetric_difference, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int&gt; v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector&lt;int&gt;::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_symmetric_difference (first, first+5, second, second+5, v.begin());
											   //  5 15 25 30 40 50  0  0  0  0
  v.resize(it-v.begin());                      //  5 15 25 30 40 50

  std::cout &lt;&lt; &quot;The symmetric difference has &quot; &lt;&lt; (v.size()) &lt;&lt; &quot; elements:\n&quot;;
  for (it=v.begin(); it!=v.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h4 id="67-set_union">6.7 set_union</h4>
<pre><code class="cpp">// set_union example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::set_union, std::sort
#include &lt;vector&gt;       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector&lt;int&gt; v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector&lt;int&gt;::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_union (first, first+5, second, second+5, v.begin());
											   // 5 10 15 20 25 30 40 50  0  0
  v.resize(it-v.begin());                      // 5 10 15 20 25 30 40 50

  std::cout &lt;&lt; &quot;The union has &quot; &lt;&lt; (v.size()) &lt;&lt; &quot; elements:\n&quot;;
  for (it=v.begin(); it!=v.end(); ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}

&gt;&gt;&gt;
The union has 8 elements:
 5 10 15 20 25 30 40 50
</code></pre>

<h2 id="7-">7- 堆</h2>
<pre><code class="cpp">is_heap 检测给定范围是否满足堆结构
is_heap_until (C++11)   检测给定范围中满足堆结构的最大子范围
make_heap   用给定范围构造出一个堆
pop_heap    从一个堆中删除最大的元素
push_heap   向堆中增加一个元素
sort_heap   将满足堆结构的范围排序
</code></pre>

<h3 id="71-is_heap">7.1 is_heap</h3>
<pre><code class="cpp">// is_heap example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_heap, std::make_heap, std::pop_heap
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; foo {9,5,2,6,4,1,3,8,7};

  if (!std::is_heap(foo.begin(),foo.end()))
	std::make_heap(foo.begin(),foo.end());

  std::cout &lt;&lt; &quot;Popping out elements:&quot;;
  while (!foo.empty()) {
	std::pop_heap(foo.begin(),foo.end());   // moves largest element to back
	std::cout &lt;&lt; ' ' &lt;&lt; foo.back();         // prints back
	foo.pop_back();                         // pops element out of container
  }
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="72-is_heap_until">7.2 is_heap_until</h3>
<pre><code class="cpp">// is_heap example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_heap_until, std::sort, std::reverse
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; foo {2,6,9,3,8,4,5,1,7};

  std::sort(foo.begin(),foo.end());
  std::reverse(foo.begin(),foo.end());

  auto last = std::is_heap_until (foo.begin(),foo.end());

  std::cout &lt;&lt; &quot;The &quot; &lt;&lt; (last-foo.begin()) &lt;&lt; &quot; first elements are a valid heap:&quot;;
  for (auto it=foo.begin(); it!=last; ++it)
	std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h3 id="73-make_heap">7.3 make_heap</h3>
<pre><code class="cpp">// range heap example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap
#include &lt;vector&gt;       // std::vector

int main () {
	int myints[] = {10,20,30,5,15};
	std::vector&lt;int&gt; v(myints,myints+5);

	std::make_heap (v.begin(),v.end());
	std::cout &lt;&lt; &quot;initial max heap   : &quot; &lt;&lt; v.front() &lt;&lt; '\n';

	std::pop_heap (v.begin(),v.end());  v.pop_back();       /// 最大值移到了v.back(). 先从堆删，再从容器删除

	std::cout &lt;&lt; &quot;max heap after pop : &quot; &lt;&lt; v.front() &lt;&lt; '\n';

	v.push_back(99); std::push_heap (v.begin(),v.end());    /// 添加，先容器，后堆
	std::cout &lt;&lt; &quot;max heap after push: &quot; &lt;&lt; v.front() &lt;&lt; '\n';

	std::sort_heap (v.begin(),v.end());

	std::cout &lt;&lt; &quot;final sorted range :&quot;;        /// final sorted range : 5 10 15 20 99
	for (unsigned i=0; i&lt;v.size(); i++)
		std::cout &lt;&lt; ' ' &lt;&lt; v[i];

	std::cout &lt;&lt; '\n';

	return 0;
}



</code></pre>

<h3 id="74-pop_heap">7.4 pop_heap</h3>
<p>同上</p>
<h3 id="75-push_heap">7.5 push_heap</h3>
<p>同上</p>
<h3 id="76-sort_heap">7.6 sort_heap</h3>
<h2 id="8-">8- 最大/最小值</h2>
<pre><code class="cpp">is_permutation (C++11)  判断一个序列是否是另一个序列的一种排序 
max 返回两个元素中值最大的元素
max_element 返回给定范围中值最大的元素
min 返回两个元素中值最小的元素
min_element 返回给定范围中值最小的元素
minmax (C++11)  返回两个元素中值最大及最小的元素
minmax_element (C++11)  返回给定范围中值最大及最小的元素
</code></pre>

<h3 id="81is_permutation">8.1is_permutation</h3>
<pre><code class="cpp">// is_permutation example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::is_permutation
#include &lt;array&gt;        // std::array

int main () {
  std::array&lt;int,5&gt; foo = {1,2,3,4,5};
  std::array&lt;int,5&gt; bar = {3,1,4,5,2};

  if ( std::is_permutation (foo.begin(), foo.end(), bar.begin()) )
	std::cout &lt;&lt; &quot;foo and bar contain the same elements.\n&quot;;

  return 0;
}
</code></pre>

<h3 id="82-max">8.2 max</h3>
<pre><code class="cpp">// max example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::max

int main () {
  std::cout &lt;&lt; &quot;max(1,2)==&quot; &lt;&lt; std::max(1,2) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;max(2,1)==&quot; &lt;&lt; std::max(2,1) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;max('a','z')==&quot; &lt;&lt; std::max('a','z') &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;max(3.14,2.73)==&quot; &lt;&lt; std::max(3.14,2.73) &lt;&lt; '\n';
  return 0;
}
</code></pre>

<h3 id="83-max_element">8.3 max_element</h3>
<pre><code class="cpp">// min_element/max_element example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::min_element, std::max_element

bool myfn(int i, int j) { return i&lt;j; }

struct myclass {
  bool operator() (int i,int j) { return i&lt;j; }
} myobj;

int main () {
  int myints[] = {3,7,2,5,6,4,9};

  // using default comparison:
  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7) &lt;&lt; '\n';

  // using function myfn as comp:
  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7,myfn) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7,myfn) &lt;&lt; '\n';

  // using object myobj as comp:
  std::cout &lt;&lt; &quot;The smallest element is &quot; &lt;&lt; *std::min_element(myints,myints+7,myobj) &lt;&lt; '\n';
  std::cout &lt;&lt; &quot;The largest element is &quot;  &lt;&lt; *std::max_element(myints,myints+7,myobj) &lt;&lt; '\n';

  return 0;
}
</code></pre>

<h2 id="9-">9- 其它</h2>
<pre><code class="cpp">lexicographical_compare 比较两个序列的字典序
next_permutation    返回给定范围中的元素组成的下一个按字典序的排列
prev_permutation    返回给定范围中的元素组成的上一个按字典序的排列
</code></pre>

<p>最后给大家推荐一个很好的C++网站，里面有学习资源、参考资源等，十分强大，各种库，各种库函数的原型及示例都有，只不过是英文，但是都写的很简洁，很好理解 
<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a></p>


<hr/>
<div class="footer">
	Copyright &copy; xiaoxiyouran. All rights reserved.

</div>

</div> <!-- /container -->

<!---------------------------------------------------------------------------------------------------------------------------->

        </TD>
  </TR>
</TABLE>

<!-- 请注意，以下两个部分的代码执行是有顺序的，必须严格按照这个顺序来。另外，放在底部是为了优化界面，使加载速度更快 -->
<!-- 为了优化代码风格 -->
<script src="../../../../packages/js/jquery-1.9.1.min.js" ></script>
<script src="../../../../packages/js/bootstrap.min.js" ></script>
<script src="../../../../packages/js/highlight.min.js" ></script>
<script >hljs.initHighlightingOnLoad();</script>

<!-- 以下是为了生成文档的侧边栏 -->
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/js/jquery.ztree.core-3.5.js"></script>
<script type="text/javascript" src="../../../../packages/generate_header_sidebar/src/ztree_toc.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
  $('#tree').ztree_toc({
    is_auto_number : true,
    use_head_anchor: true
  });
});
//-->
</SCRIPT>

</body>
</html>
    